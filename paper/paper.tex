
\documentclass[a4paper,USenglish]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory
\usepackage{minted}

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Subsidiary Recursion in Coq} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Aaron Stump}{Computer Science Dept., The University of Iowa, USA \and \url{http://www.cs.uiowa.edu/~astump/}}{aaron-stump@uiowa.edu}{http://orcid.org/0000-0002-9720-0003}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Alex Hubers}{Computer Science, The University of Iowa, USA}{alexander-hubers@uiowa.edu}{}{}

\author{Christopher Jenkins}{Computer Science, The University of Iowa, USA}{alexander-hubers@uiowa.edu}{http://orcid.org/
0000-0002-5434-5018}{}

\author{Benjamin Delaware}{Computer Science, Purdue University, USA \and \url{https://www.cs.purdue.edu/homes/bendy/}}{bendy@purdue.edu}{}{}

\authorrunning{A. Stump, A. Hubers, C. Jenkins, and B. Delaware} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Aaron Stump, Alex Hubers, Christopher Jenkins, and Benjamin Delaware} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{Software and its engineering~Recursion}
\ccsdesc[100]{Software and its engineering~Polymorphism}

\keywords{strong functional programming, recursion schemes, positive-recursive types, impredicativity} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{June Andronick and Leonardo da Moura}
\EventNoEds{2}
\EventLongTitle{Interactive Theorem Proving 2022}
\EventShortTitle{ITP 2022}
\EventAcronym{ITP}
\EventYear{2022}
\EventDate{2022}
\EventLocation{}
\EventLogo{}
\SeriesVolume{}
\ArticleNo{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\all}[2]{\forall\, #1.\, #2}


\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
  This paper describes a functor-generic derivation in Coq of
  subsidiary recursion.  On this recursion scheme, inner recursions
  may be initiated within outer ones, in such a way that outer
  recursive calls may be made on results from inner ones.  The
  derivation utilizes a novel (necessarily weakened) form of
  positive-recursive types in Coq, dubbed retractive-positive
  recursive types.  A corresponding form of induction is also
  supported.  The method is demonstrated through several examples.
\end{abstract}

\section{Introduction: subsidiary recursion}
\label{sec:intro}

Central to interactive theorem provers like Coq, Agda, Isabelle/HOL,
Lean and others are terminating recursive functions over user-declared
inductive datatypes~\cite{agda,coq,isabelle-hol,lean}.  Termination is
usually enforced by a syntactic check for structural decrease, which
is sufficient for many basic functions.  For example, the
\texttt{span} function from Haskell's prelude (\verb|Data.List|) takes
a list and returns a pair of the maximal prefix whose elements satisfy
a given predicate \verb|p|, and the remaining suffix:
\begin{minted}{haskell}
span :: (a -> Bool) -> [a] -> ([a],[a])
span _ []    =  ([], [])
span p (x:xs) = if p x
                then let (ys,zs) = span p xs in (x:ys,zs)
                else ([],x:xs)
\end{minted}
\noindent The sole recursive call is \verb|span p xs|, and it occurs
in a clause where the input list is of the form \verb|x:xs|.  Hence it
is structurally decreasing.  In the appropriate syntax, this
definition can be accepted without additional effort by all the
mentioned provers.

This paper is about a more expressive form of terminating recursion,
called \textbf{subsidiary recursion}.  While performing an outer
recursion on some input \verb|x|, one may initiate an inner recursion
on \verb|x| (or possibly some of its subdata), preserving the
possibility of further invocations of the outer recursive function.
Let us see a simple example.  The function \verb|wordsBy|
(\verb|Data.List.Extra|) breaks a list into its maximal sublists whose
elements do not satisfy a predicate \verb|p|.  For example,
\verb|wordsBy isSpace " good day "| returns \verb|["good","day"]|.
Code is in Figure~\ref{fig:wordsBy}.  Recall that
\verb|break p| is equivalent to \verb|span (not . p)|. The first recursive call,
\verb|wordsBy p tl|, is structural.  But in the second, we invoke
\verb|wordsBy p| on a value obtained from another recursion, namely
\verb|span|.  This is not allowed under structural termination, but
will be permitted by subsidiary recursion.

\begin{figure}
\begin{minted}{haskell}
wordsBy :: (a -> Bool) -> [a] -> [[a]]
wordsBy p [] = []
wordsBy p (hd:tl) =
  if p hd
  then wordsBy p tl 
  else let (w,z) = break p tl in
        (hd:w) : wordsBy p z
\end{minted}
\caption{Haskell code for \texttt{wordsBy}, demonstrating subsidiary recursion}
\label{fig:wordsBy}
\end{figure}

\subsection{Summary of results}

This paper presents a functor-generic derivation of terminating
subsidiary recursion and induction in Coq.  We emphasize that this is
a derivation within the type theory of Coq, and requires no axioms or
other modifications to Coq, except the \verb|-impredicative-set|
flag. Using this derivation, we present several example functions like
\verb|wordsBy|, and prove theorems about them.  A nice example is a
definition of run-length encoding using \verb|span| as a subsidiary
recursion, where we prove that encoding and then decoding returns the
original list.  Our approach applies to the standard datatypes in the
Coq library, and does not require switching libraries or datatype
definitions.

An important technical novelty is a derivation of a weakened form of
positive-recursive type in Coq.  Coq (Agda, and Lean) restrict
datatypes $D$ to be strictly positive: in the input types of
constructors of $D$, $D$ cannot occur to the left of any arrows.  Our
derivation needs to use positive-recursive types, where $D$ may occur
to the left of an even number (only) of arrows.  We present a way to
derive a weakened form of positive-recursive type that is sufficient
for our examples (Section~\ref{sec:mu}).  The weakening is to require
only that $F\ (\mu F)$ is a retract of $\mu F$.  Usually these types are
isomorphic.  Hence, we dub these \textbf{retractive-positive}
recursive types.  This weakening leads to noncanonical elements of
$\mu$, but we will see how to work around this.  Our definition of
retractive-positive recursive types makes essential use of
impredicative quantification, and hence is not legal in predicative
theories like Agda's.

We begin by summarizing the interface our derivation provides for
subsidiary recursion (Section~\ref{sec:interface}), and then see
examples (Section~\ref{sec:examples}).  We next explain how the
interface is actually implemented (Section~\ref{sec:deriv}), including
our retractive-positive recursive types (Section~\ref{sec:mu}).  The
interface for subsidiary induction is covered next
(Section~\ref{sec:interfacei}), and example proofs using it
(Section~\ref{sec:examplesi}).  Related work is discussed in
Section~\ref{sec:related}.

All presented derivations have been checked with Coq version 8.13.2.  The code may be
found as release \verb|itp-2022| (dated prior to the ITP 2022
deadline) at \url{https://github.com/astump/coq-subsidiary}.  The
paper references files in this codebase, as an aid to the reader
wishing to peruse the code.

\section{Interface for subsidiary recursion}
\label{sec:interface}

This section presents the interface our Coq development provides
for subsidiary recursion.

\subsection{The recursion universe}
\label{sec:recu}

Our approach is within a long line of work using ideas from universal
algebra and category theory to describe inductive datatypes and their
recursion principles (cf.~\cite{traytel12,cockett92,hagino87}).  On this approach, one describes transformations
to be performed on data as \emph{algebras}, which can then be
\textit{folded} over data.  The simplest form of algebras, namely
$F$-algebras for functor $F$, are morphisms from $F\ A$ to $A$, for carrier object
$A$.  From a programming perspective, an $F$-algebra is given input of
type $F\ A$, and must compute a result of type $A$.  An example of $F$
is the signature functor for lists, which we will use below:

\begin{minted}{coq}
Inductive ListF(X : Set) : Set :=
| Nil : ListF X
| Cons : A -> X -> ListF X.
\end{minted}

Algebras for our subsidiary recursion are more complex than
$F$-algebras.  Let us begin with an informal explanation.  For reasons
we will explain further below, the carrier of the algebra will be a
functor \verb|X : Set -> Set|.  The algebra is presented with:

\begin{itemize}
\item a type \verb|R : Set|, which will be this recursion's view of the datatype.
\item a function \verb|fold : FoldT Alg R|, which allows one to
  initiate subsidiary recursions over data of type \verb|R|.  We will
  present the type \verb|FoldT Alg R| below.
\item a function \verb|rec : R -> X R|, to use for making recursive calls, on any value of type \verb|R|.
\item and a \emph{subdata structure} \verb|d : F R|, where \verb|F| is the signature functor for the datatype.
\end{itemize}

\noindent The algebra is then required to produce a value of type \verb|X R|.

We will use Coq inductive types for the signature functors \verb|F| of
various datatypes, thus enabling recursions to use Coq's
pattern-matching on the subdata structure \verb|d|.  So the style of
coding against this interface retains a similar feel to structural
recursion.  Unlike with structural termination, though, the interface
here is type-based and hence compositional.  

We have previously dubbed this interface a \emph{recursion
universe}~\cite{stump20}.  As in other domains using the term
``universe'', we have a kind of space (here, \verb|R|), which one
cannot escape using certain operations.  Other examples are the
ordinal $\epsilon_0$ and $\omega^-$, and the physical universe and
traveling at the speed of light.  Staying in the recursion universe is
good, because we may recurse (via \verb|rec|) on any value of type
\verb|R|.  Some points must still be explained: why \verb|X| has type
\verb|Set -> Set|, and the definition of \verb|FoldT|.  Let us see
these details next.

\subsection{Types for subsidiary recursion (\texttt{Subrec.v}, \texttt{List.v})}


\begin{figure}
\begin{minted}{coq}
Definition List := Subrec ListF.
Definition inList : ListF List -> List := inn ListF.
Definition mkNil : List := inList Nil.
Definition mkCons (hd : A) (tl : List) : List := inList (Cons hd tl).
Definition toList : list A -> List.
Definition fromList : List -> list A.
\end{minted}
  \caption{Some basics from \texttt{List.v}, specializing the functor-generic derivation of subsidiary recursion to lists (\texttt{List.v})}
  \label{fig:listf}
\end{figure}

The type over which one can recurse with our scheme of subsidiary
recursion is called \verb|Subrec|.  It is parametrized by a signature
functor \verb|F| of type \verb|Set -> Set|.  \verb|Subrec| comes with
\verb|inn : F Subrec -> Subrec|, which behaves computationally like a
constructor.  We will later derive an induction principle for this type
(Section~\ref{sec:interfacei}). The definition of \verb|Subrec| uses
retractive-positive recursive types, to take a fixed-point of a
construction based on \verb|F|.  We present these recursive types in
Section~\ref{sec:mu} below.

For our examples, we will consider the specialization to the case of
lists, parametrized by the type \verb|A| of elements.  In general, to
use our development to get subsidiary recursion over some datatype,
one must define a signature functor for the datatype.  For lists, this
is \verb|ListF|, which we saw at the start of Section~\ref{sec:interface}.  \verb|List| is defined to
be \verb|Subrec|, with \verb|F| instantiated to \verb|ListF A|.  This
type \verb|List| is not to be confused with the type \verb|list| of
lists in Coq's standard library.  As noted previously, our development
is meant to be used in extension of existing inductive datatypes, not
replacing them.  The figure also shows constructors \verb|mkNil| and
\verb|mkCons| for \verb|List|, and typings for conversion functions
between \verb|List| and \verb|list| (code elided). 
  

\subsection{Algebras for subsidiary recursion}

\verb|Subrec.v| also implements the notion of algebra we introduced
informally above.  The central definitions are in
Figure~\ref{fig:algf}.  \verb|KAlg| is the kind for the
type-constructor for algebras, as we see in the definition of
\verb|Alg|.  This type-constructor \verb|Alg| is a fixed-point of the
type \verb|AlgF|.  The fixed-point is taken using \verb|MuAlg|, which
implements our retractive-positive recursive types
(Section~\ref{sec:mu}) at kind \verb|KAlg|.  

We need a fixed-point here due to the input \verb|fold| (\verb|Algf|)
of type \verb|FoldT Alg R|.  This is the type for fold functions which
apply algebras (\verb|Alg|) to data of type \verb|R|.  The variable \verb|Alg| occurs only positively (but not
strictly positively) in \verb|AlgF|, because it occurs negatively in
\verb|FoldT Alg R| which occurs negatively in \verb|AlgF Alg X|.  So
we can indeed take a fixed-point of \verb|AlgF| to define the constant
\verb|Alg|.

\begin{figure}
\begin{minted}{coq}
Definition KAlg  : Type := (Set -> Set) -> Set.

Definition FoldT(alg : KAlg)(C : Set) : Set :=
  forall (X : Set -> Set) (FunX : Functor X), alg C X -> C -> X C.

Definition AlgF(Alg: KAlg)(X : Set -> Set) : Set :=
  forall (R : Set)
         (fold : FoldT Alg R)
         (rec : R -> X R)      
         (d : F R),             
         X R.

Definition Alg : KAlg := MuAlg AlgF.

Definition fold : FoldT Alg Subrec.
Definition rollAlg : forall {X : Set -> Set}, AlgF Alg X -> Alg X.
Definition unrollAlg : forall {X : Set -> Set}, Alg X -> AlgF Alg X.
\end{minted}
\caption{The type for algebras, parametrized over \texttt{F : Set -> Set} (\texttt{Subrec.v})}
\label{fig:algf}
\end{figure}


Let us look at \verb|AlgF|.  As noted already, each recursion is based
on an abstract type \verb|R|, representing the data upon which we will
recurse.  This is the first argument to a value of type
\verb|AlgF Alg X|.  Reasoning parametrically, an algebra can assume
nothing about \verb|R| except that it supports the following
operations.  Next we have a local
\texttt{fold} function, which will allow us to fold another algebra over data
of type \verb|R|.  We will use \verb|fold| to initiate subsidiary
recursions.  Then there is \verb|rec|, for recursive calls on data of
type \verb|R|.

As noted already, for subsidiary recursion, algebras have a carrier
\verb|X| which depends (functorially) on a type.  When we fold an
algebra using a fold function (either global or local) of type
\verb|FoldT Alg C|, (i) recursive calls may compute a result of type
\verb|X R|, mentioning the abstract type \verb|R| for that recursion;
and (ii) outside that recursion, the result will have type \verb|X C|.
Having a functor for the carrier of the algebra gives us the
flexibility to type results inside a recursion with the abstract type
\verb|R|, but view those results as having the type \verb|C| outside
the recursion.  The function \verb|fold| in the figure initiates
top-level folds.  We also can have functions 
between \verb|Alg| and its \verb|Algf|-unfolding.  We will
return to the code for \verb|Subrec.v| in Section~\ref{sec:deriv}.

Finally, for a recursion scheme, one would like to see not just the
typed interface, but also the computation law.  This is shown as a
theorem in Figure~\ref{fig:comp}.  Intuitively, it states that
\verb|fold|ing an algebra over constructed data \verb|inn d| is equal
to invoking the algebra on \verb|fold|
for the fold function; an invocation of \verb|fold| with the algebra
for the \verb|rec| function; and \verb|d| for the subdata structure.

\begin{figure}
\begin{minted}{coq}
Theorem FoldChar :
 forall (X : Set -> Set) (FunX : Functor X) (IdF : FmapId X FunX)
        (algf : AlgF Alg X) (d : F Subrec),
 fold X FunX (rollAlg algf) (inn d) =
   algf _ fold (fold X FunX (rollAlg algf)) d .
\end{minted}
\caption{Computation law for subsidiary recursion, stated as a theorem}
\label{fig:comp}
\end{figure}

\section{Examples of subsidiary recursion}
\label{sec:examples}

Having seen the interface for subsidiary recursion in Coq, let us
consider now some examples.  

\subsection{The \texttt{span} function (\texttt{Span.v})}

This first example does not invoke subsidiary recursions, but will
itself be used as a subsidiary recursion in other examples to follow.
Given a predicate \verb|p : A -> bool|, and a value of type
\verb|List A|, we would like to compute a pair of type
\verb|list A * List A|, where the first component is the maximal
prefix whose elements satisfy \verb|p|, and the second is the
remaining suffix.  This is the typing for a top-level recursion.  More
generally, though, given a type \verb|R : Set| along with a
fold function for that type (i.e., of type
\verb|FoldT (Alg (ListF A)) R|), we would like to map an input list of
type \verb|R| to a pair of type \verb|list A * R|.  The first
component of this pair is going to be built up from scratch, and so
cannot have type \verb|R|; we cannot statically ensure that outer
recursions on it are legal.  But the second component will be a
subdatum of the input list, and so can still have type \verb|R|,
enabling outer recursive calls.  So we want:
\begin{minted}{coq}
Definition spanr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                (p : A -> bool)(xs : R) : list A * R.
\end{minted}
\noindent From this we can also define the top-level recursion, by
supplying \verb|fold (ListF A)|, which is the function for folding an algebra
over a list (Figure~\ref{fig:algf}), for the argument \verb|fo| of \verb|spanr|:
\begin{minted}{coq}
Definition span(p : A -> bool)(xs : List A) : list A * List A
  := spanr (fold (ListF A)) p xs.
\end{minted}

Before we define \verb|spanr|, we must resolve a small problem.
If the first element of the input list
\verb|xs| to \verb|span| does not satisfy \verb|p|, then \verb|span|
should return \verb|([], xs)|.  But when recursing on \verb|xs|, we
will see it only in the form of a subdata structure of type
\verb|ListF A R|.  We will not be able to return it from our recursion at
type \verb|R|, and hence we would not be able to return \verb|([],xs)|
as desired.  To work around this, we will have our recursion return a value
of type \verb|SpanF R| (\verb|X| will be implicit for the constructors):
\begin{minted}{coq}
Inductive SpanF(X : Set) : Set :=
  SpanNoMatch : SpanF X
| SpanSomeMatch : list A -> X -> SpanF X.
\end{minted}
\noindent The idea is that the recursion will signal if it is in the
one tricky case where \verb|p| does not match the first element, by
returning \verb|SpanNoMatch|.  Otherwise, it will be able to return,
via \verb|SpanSomeMatch|, a prefix and the suffix at type
\verb|R|. The prefix will be nonempty, and hence the suffix will be at
most the tail of \verb|xs|.  This suffix is available to the algebra
in the subdata structure of type \verb|ListF A R|.

\subsubsection{The algebra for \texttt{span}}


\begin{figure}
\begin{minted}{coq}
Definition SpanAlg(p : A -> bool) : Alg (ListF A) SpanF :=
  rollAlg (fun R fo span xs => 
     match xs with
         Nil => SpanNoMatch 
       | Cons hd tl =>
          if p hd then
            match (span tl) with
              SpanNoMatch => SpanSomeMatch [hd] tl
            | SpanSomeMatch l r => SpanSomeMatch (hd::l) r
            end
          else
            SpanNoMatch 
       end).
\end{minted}
\caption{The algebra \texttt{SpanAlg} for the \texttt{span} function (\texttt{Span.v})}
\label{fig:spanalg}
\end{figure}

Figure~\ref{fig:spanalg} show the algebra
\verb|SpanAlg|, whose type is \verb|Alg (ListF A) SpanF|.  So we are defining
an algebra (\verb|Alg|) for the \verb|ListF A| functor, with carrier
\verb|SpanF| of the required type \verb|Set -> Set|.  We use
\verb|rollAlg| to create an algebra from something whose type is an
application of \verb|AlgF|.  This takes in all the components of the
recursion universe: the abstract type \verb|R|, the fold function
(\verb|fo|) for any subsidiary recursions (not needed here), a
function we choose to name \verb|span| for making recursive calls, and
finally \verb|xs : ListF A R|.  The algebra pattern-matches on this
\verb|xs|.  In the cases where it is empty or where its head
(\verb|hd|) does not satisfy \verb|p|, we return \verb|SpanNoMatch|.
This signals to the caller that we really wished to return
\verb|([],xs)|, but could not because we do not have \verb|xs| at type
\verb|R|.  If the head does satisfy \verb|p|, then we recurse on the
tail (\verb|tl : R|) by calling the provided
\verb|span : R -> SpanF R|.  If \verb|span tl| returns
\verb|SpanNoMatch|, that means that we should make \verb|tl| the
suffix in the pair we return (via \verb|SpanSomeMatch|).  Happily, we
have \verb|tl : R| here, so we can do this.  In either case (for
return value of \verb|span tl|), we add the head to the front of the
prefix.

\subsubsection{Defining \texttt{span} from \texttt{SpanAlg}}

\verb|SpanAlg| is used in the definition of \verb|spanhr|, in
Figure~\ref{fig:span}.  This function invokes the fold function it is
given, on \verb|SpanAlg|.  The final twist is now in the definition of
\verb|spanr|.  We call \verb|spanhr| on the input \verb|xs : R|.  If
\verb|spanhr| returns \verb|SpanNoMatch|, then we are supposed to
return \verb|([],xs)|, which we can do here, because we have
\verb|xs : R|.  It was only inside the algebra that we lost the
information that the subdata structure of type \verb|F R| is derived
from a value of type \verb|R|.  If \verb|spanhr| returns
\verb|SpanSomeMatch l r|, then we return the nonempty
prefix (\verb|l|) and the suffix (\verb|r|).  We also define a version of \verb|break| 
for subsidiary recursion (e.g., in \verb|wordsBy|, below).


\begin{figure}
\begin{minted}{coq}
Definition spanhr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                 (p : A -> bool)(xs : R) : SpanF R :=
  fo SpanF SpanFunctor (SpanAlg p) xs.

Definition spanr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                (p : A -> bool)(xs : R) : list A * R
  := match spanhr fo p xs with
       SpanNoMatch => ([],xs)
     | SpanSomeMatch l r => (l,r)
     end.

Definition breakr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                 (p : A -> bool)(xs : R) : list A * R :=
  spanr fo (fun x => negb (p x)) xs.
\end{minted}
\caption{Functions derived from \texttt{SpanAlg} (\texttt{Span.v})}
\label{fig:span}
\end{figure}


\subsection{The \texttt{wordsBy} function (\texttt{WordsBy.v})}

Let us now see how to write \verb|wordsBy|, our example function from
Section~\ref{sec:intro}, using \verb|breakr| subsidiarily.  The code
is in Figure~\ref{fig:wordsby}, assuming a type \verb|A : Set|.  The
setup is similar to that for \verb|span|.  We first define an algebra
\verb|WordsBy|, parametrized by the predicate \verb|p|, of type
\verb|Alg (ListF A) (Const (list (list A)))|.  This says that
\verb|WordsBy p| is an algebra (\verb|Alg|) for the \verb|ListF A|
functor, with carrier \verb|Const (list (list A))|.  \verb|Const| is
a combinator for creating the object part of constant functors;
\verb|FunConst| creates the morphism part (i.e., the \verb|fmap|
function).  We use \verb|Const| where the return type of the algebra
will not depend on its abstract type \verb|R|.  Here, we are
constructing from scratch a list of lists, so it will not be legal to
recurse on the list itself, or its (list) elements.  So we just use
the \verb|list| type of Coq's standard library.

The code for \verb|WordsBy| is essentially
the same as what we saw in Section~\ref{sec:intro}.  We pattern match
on \verb|xs : ListF A R|.  Recall that for this function, we are
trying to drop elements which satisfy \verb|p|, and return a list of
the sublists between maximal sequences of such elements.  In the
\verb|Cons| case, if the head (\verb|hd|) satisfies the predicate, then we are
supposed to drop it and recurse.  This is legal, because \verb|tl : R|
and \verb|wordsBy : R -> list (list A)|.  In the \verb|else| case,
we use \verb|breakr| to obtain the maximal prefix \verb|w| of \verb|tl| that
does not satisfy \verb|p|, and the remaining suffix \verb|z|.

Here we see the benefit of our approach.  From Figure~\ref{fig:span},
the return type of \verb|breakr| is \verb|list A * R|, where \verb|R|
comes from the type \verb|FoldT (ListF A) Alg R| of
\verb|fo|, from the definition
of \verb|AlgF| in Figure~\ref{fig:algf} (instantiating the functor
with \verb|ListF A|).  This means that from the invocation of
\verb|breakr|, we get \verb|w : list A| and \verb|z : R|.  And so we
can indeed apply \verb|wordsBy : R -> list (list A)| to
\verb|z| to recurse.  The figure also shows the code for the subsidiary
recursion \verb|wordsByr|.

\begin{figure}
\begin{minted}{coq}
  Definition WordsBy(p : A -> bool)
    : Alg (ListF A) (Const (list (list A))) :=
    rollAlg (fun R fo wordsBy xs => 
      match xs with
        Nil => [] 
      | Cons hd tl =>
        if p hd then
          wordsBy tl
        else
          let (w,z) := breakr fo p tl in
            (hd :: w) :: wordsBy z
      end).
Definition wordsByr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                   (p : A -> bool)(xs : R) : list (list A) :=
  fo (Const (list (list A))) (FunConst (list (list A))) (WordsBy p) xs.
\end{minted}
\caption{Functions  \texttt{wordsBy} and \texttt{wordsByr}, and the algebra they
  fold (\texttt{WordsBy.v})}
\label{fig:wordsby}
\end{figure}

\subsection{The \texttt{mapThrough} function (\texttt{MapThrough.v})}

\begin{figure}
\begin{minted}{haskell}
mapThrough :: (a -> [a] -> (b, [a])) -> [a] -> [b]
mapThrough f [] = []
mapThrough f (a:as) = b : mapThrough f as'
    where (b, as') = f a as
\end{minted}
\caption{The \texttt{mapThrough} function in Haskell}
\label{fig:mapthroughhs}
\end{figure}

In this example, we see how to write a combinator that factors out a
subsidiary recursion.  The Haskell library \verb|Data.List.Extra| has
a function \verb|repeatedly|, defined essentially as in
Figure~\ref{fig:mapthroughhs}, though we attempt a more informative
name.  This is like the standard \verb|map| function on lists, except
that the function \verb|f| that we are mapping (or ``mapping
through'') takes in not just the current element \verb|a|, but also
the tail \verb|as|.  It then returns the value \verb|b| to include in
the output list, and whatever other list it wishes, upon which
\verb|mapThrough| will recurse.

To write this combinator using our infrastructure for subsidiary
recursion, we need to supply the mapped function with the fold
function for \verb|mapThrough|'s recursion.  This is so that the
mapped function can initiate a subsidiary recursion, returning a value
in the abstract type \verb|R| of \verb|mapThrough|'s recursion.  So
the type we will use for mapped functions is:
\begin{minted}{coq}
Definition mappedT(A B : Set) : Set :=
  forall(R : Set)(fo:FoldT (Alg (ListF A)) R), A -> R -> B * R.
\end{minted}
\noindent This type is more informative than the Haskell type,
since it shows that the second component of the returned value
must have type \verb|R|, and hence must be (hereditarily) a tail
of the input.

Given this definition, the code is in Figure~\ref{fig:mapthrough}.  
\verb|MapThroughAlg| is similar to the
Haskell code above, though when we call \verb|f|, we must
supply the abstract type \verb|R| and fold function \verb|fo|.  Then,
from the definition of \verb|mappedT|, we have that \verb|b : B| and
\verb|c : R|.  So we may indeed invoke \verb|mapThrough : R -> list B|
on \verb|c|.  Note that as we are building up a new list from scratch
(rather than just extracting some tail of the input list), we just
return \verb|list B|; we cannot perform further subsidiary recursion
on the output.  

\begin{figure}
\begin{minted}{coq}
Definition MapThroughAlg{B : Set}(f:mappedT A B)
  : Alg (ListF A) (Const (list B)) :=
  rollAlg (fun R fo mapThrough xs => 
    match xs with
      Nil => []
    | Cons hd tl =>
      let (b,c) := f R fo hd tl in
        b :: mapThrough c
    end).
Definition mapThroughr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                      {B : Set}(f:mappedT A B) : R -> list B.
Definition mapThrough{B : Set}(f:mappedT A B) : List A -> list B.
\end{minted}
\caption{The algebra \texttt{MapThroughAlg} defining function \texttt{mapThrough} and \texttt{mapThroughr}; the
  code for those follows the pattern of \texttt{wordsBy} and \texttt{wordsByr} (Figure~\ref{fig:wordsby}), so
  we omit it (\texttt{MapThrough.v})}
\label{fig:mapthrough}
\end{figure}

\subsection{Run-length encoding (\texttt{Rle.v})}

\begin{figure}
\begin{minted}{haskell}
rle :: Eq a => [a] -> [(Int,a)]
rle = mapThrough compressSpan
  where compressSpan a as =
          let (p,s) = span (== a) as in
            ((1 + length p, a),s)
\end{minted} 
\caption{Run-length encoding in Haskell, using \texttt{mapThrough} and \texttt{span}}
\label{fig:rlehs}
\end{figure}

Finally, we have an example using our \verb|mapThrough| combinator
together with a subsidiary recursion, to implement \emph{run-length
encoding}.  This is a basic data-compression algorithm where maximal
sequences of $n$ occurrences of element $e$ are summarized by the pair
$(n,e)$~\cite{datacomp}.  Haskell code is in Figure~\ref{fig:rlehs}.
Recall that \verb|(== a)| tests its input for equality with \verb|a|.
The \verb|compressSpan| helper function gathers up all elements at the
start of the tail \verb|as| that are equal to the head \verb|a|.  This
prefix is returned as \verb|p|, with the remaining suffix as \verb|s|.
The pair \verb|(1 + length p, a)| is returned to summarize
\verb|a :: p|.  The \verb|mapThrough| combinator then iterates
\verb|compressSpan| through the suffix \verb|s|.

Assuming \verb|A : Set| and an equality test \verb|eqb : A -> A -> bool| on it,
we port this code to our Coq infrastructure in Figure~\ref{fig:rle}.
The function \verb|compressSpan| is written at the type \verb|mappedT A (nat * A)| that
will be required by \verb|mapThrough|.  Unfolding the definition of \verb|mappedT|,
\verb|compressSpan| has type:
\begin{minted}{coq}
forall(R : Set)(fo:FoldT (Alg (ListF A)) R), A -> R -> (nat * A) * R.
\end{minted}
\noindent It is invoked by the code for \verb|mapThrough| with \verb|fo : FoldT (Alg (ListF A)) R|.  It then has the
responsibility of extracting from the tail at type \verb|R| (second input) 
a result upon which \verb|mapThrough| should recurse (second component
of the output pair).  Then we define an algebra \verb|RleAlg| by
supplying \verb|compressSpan| as the function to map through, to
\verb|MapThroughAlg| (Figure~\ref{fig:mapthrough}).  Following the
pattern seen above, we define function \verb|rle| for top-level
recursions using \verb|fold| (we could also define a subsidiary version
\verb|rler|).



\begin{figure}
\begin{minted}{coq}
Definition compressSpan : mappedT A (nat * A) :=
  fun R fo hd tl => 
    let (p,s) := spanr fo (eqb hd) tl in
       ((succ (length p),hd), s).

Definition RleCarr := Const (list (nat * A)).
Definition RleAlg : Alg (ListF A) RleCarr :=
  MapThroughAlg compressSpan.
Definition rle(xs : List A) : list (nat * A)
  := fold (ListF A) RleCarr (FunConst (list (nat * A))) RleAlg xs.
\end{minted}
\caption{The function \texttt{rle} for run-length encoding, and the algebra \texttt{RleAlg} defining it
in terms of \texttt{MapThroughAlg} of Figure~\ref{fig:mapthrough} (\texttt{Rle.v})}
\label{fig:rle}
\end{figure}

\section{Derivation of subsidiary recursion}
\label{sec:deriv}

Let us now consider the implementation of the
interface we have used for the preceding examples.
The first step is our weakened form of positive-recursive
types.

\subsection{Retractive-positive recursive types (\texttt{Mu.v})}
\label{sec:mu}

As we have seen, our definitions require a form of positive-recursive
types, to allow algebras to accept fold functions that themselves
require algebras, and also for the definition of \verb|Subrec| (which
we will see in more detail in the next section).  Full
positive-recursive types are incompatible with Coq's type
theory~\cite{coquand88}.  One can impose some restrictions on large
eliminations which then enable positive-recursive
types~\cite{blanqui05}, but this requires changing the underlying
theory.  Here we exploit Coq's
impredicative polymorphism for a different solution.

Assume \verb|F : Set -> Set|, with an \verb|fmap| function
(morphism part of the functor) of type
\begin{minted}{coq}
forall A B : Set, (A -> B) -> F A -> F B
\end{minted}
\noindent which satisfies the identity-preservation law for functors:
\begin{minted}{coq}
fmapId : forall (A : Set)(d : F A), fmap (fun x => x) d = d
\end{minted}
\noindent Then we make the definitions of Figure~\ref{fig:mu}.  The critical
idea is embodied in the definition of \verb|Mu|.  Ideally, we would like
to have a definition like
\begin{minted}{coq}
  Inductive Mu' : Set := mu' : F Mu' -> Mu'.
\end{minted}
\noindent This is exactly what is used in approaches to modular
datatypes in functional programming, like
Swierstra's~\cite{swierstra08}.  But this definition is (rightly)
rejected by Coq, as instantiations of
\verb|F| that are not strictly positive would be unsound.

\begin{figure}
\begin{minted}{coq}
  Inductive Mu : Set := 
    mu : forall (R : Set), (R -> Mu) -> F R -> Mu.

  Definition inMu(d : F Mu) : Mu :=
    mu Mu (fun x => x) d.

  Definition outMu(m : Mu) : F Mu :=
    match m with
    | mu A r d => fmap r d
    end.

  Lemma outIn(d : F Mu) : outMu (inMu d) = d.
\end{minted}
\caption{Derivation of retractive-positive recursive types (\texttt{Mu.v})}
\label{fig:mu}
\end{figure}  


The definition of \verb|Mu| in Figure~\ref{fig:mu} weakens
this to a strictly positive approximation. Instead of taking in \verb|F Mu|, constructor \verb|mu|
accepts an input of type \verb|F R|, for some type \verb|R| for which
we have a function of type \verb|R -> Mu|.  The impredicative
quantification of \verb|R| is essential here: we will instantiate it with
\verb|Mu| itself in the definition of \verb|inMu|
(Figure~\ref{fig:mu}).  So this approach would not work in a
predicative theory like Agda's.  The quantification of \verb|R| can be
seen as applying a technique due to Mendler, of introducing
universally quantified variables for problematic type occurrences, to
a datatype constructor.  We will review this in
Section~\ref{sec:related}.

Returning to Figure~\ref{fig:mu}, we have functions \verb|inMu| and
\verb|outMu|, which make \verb|F Mu| a retraction (\verb|outIn|) of
\verb|Mu|: the composition of \verb|outMu| and \verb|inMu| is
(extensionally) the identity on \verb|F Mu|.  But the reverse
composition cannot be proved to be the identity, because of the basic
problem of \textbf{noncanonicity} that arises with this definition.

For a simple example: suppose we instantiate \verb|F| with
\verb|ListF| (of Figure~\ref{fig:listf}).  Our derivation uses a
different type that wraps \verb|F|, but this will show the issue in a
simple form.  Let us temporarily define \verb|List A| as
\verb|Mu (ListF A)| (again, for subsidiary recursion do not use just
\verb|ListF| directly).  The canonical way to define the empty list
would be, implicitly instantiating \verb|F| to \verb|ListF A|,
\begin{minted}{coq}
Definition mkNil := mu (List A) (fun x => x) (NilF A)
\end{minted}
\noindent But given this, there are infinitely many other equivalent
definitions.  For any \verb|Q : Set|, we could take
\begin{minted}{coq}
Definition mkNil' := mu Q (fun x => mkNil) (NilF A)
\end{minted}
\noindent Since \verb|fmap f (NilF A)| equals \verb|NilF B| for
\verb|f : A -> B|, if we apply \verb|outMu| (of Figure~\ref{fig:mu})
to \verb|mkNil'| or \verb|mkNil|, we will get \verb|NilF (List A)|.
But critically, \verb|mkNil| and \verb|mkNil'| are not equal, neither
definitionally nor provably.  One can define a function that puts
\verb|Mu| values in normal form by folding \verb|inMu| over them.
Then \verb|mkNil| and \verb|mkNil'| will have the same normal form,
and be equivalent in that sense.  But the fact that they are not
provably equal is what we term noncanonicity.  

Noncanonicity must be handled carefully when reasoning about functions
defined with our interface.  We will see an example in
Section~\ref{sec:examplesi}.  First, though, let us complete the
exposition of our implementation of subsidiary recursion.

\subsection{The implementation of \texttt{Subrec} (\texttt{Subrec.v})}
\label{sec:subrecimpl}

The type \verb|Subrec| is defined in Figure~\ref{fig:subrec}, as a
fixed-point of \verb|SubrecF : Set -> Set|.  We take this fixed-point
with \verb|Mu|, discussed in the previous section, and obtain \verb|roll|
and \verb|unroll| functions between \verb|SubrecF Subrec| and \verb|Subrec|.
Unrolling \verb|Subrec| gives us the type
\begin{minted}{coq}
forall (X : Set -> Set) (FunX : Functor X), Alg X -> X Subrec
\end{minted}
\noindent So we see that \verb|Subrec| is the type of functions which,
for all algebras with functorial carrier
\verb|X|, compute a value of type \verb|X Subrec|.  This is a
generalization of the functor-generic type
$\forall\ X.\ \textit{Alg}\ X \to X$ for the Church encoding, where
$\textit{Alg}\ X$ is $F\ X \to X$.  We elide the implementation of the
\verb|roll| and \verb|unroll| functions, but note that \verb|unroll|
makes use of functoriality of carriers \verb|X|.

\begin{figure}
\begin{minted}{coq}
Definition SubrecF(C : Set) := 
  forall (X : Set -> Set) (FunX : Functor X), Alg X -> X C.
Definition Subrec := Mu SubrecF.
Definition roll: SubrecF Subrec -> Subrec.
Definition unroll: Subrec -> SubrecF Subrec.
\end{minted}
\caption{Definition of \texttt{Subrec} as a fixed-point of \texttt{SubrecF} (\texttt{Subrec.v})}
\label{fig:subrec}
\end{figure}

The rest of the interface for \verb|Subrec| is shown in
Figure~\ref{fig:subrecb}.  To \verb|fold| an algebra
\verb|alg| with carrier \verb|X| (with \verb|fmap| function given by
\verb|FunX|) over \verb|d : Subrec|, we \verb|unroll| the
definition of \verb|Subrec| and apply that to the algebra (with its
carrier).

More interesting is the definition of \verb|inn|, which is the
critical point where the recursion universe is implemented.  To create
a value of type \verb|Subrec| from data of type \verb|F Subrec|, the
definition of \verb|inn| \verb|roll|s a value of type
\verb|SubrecF Subrec| (we saw this type unfolded at the start of
this section).  This value takes in a carrier
\verb|X|, its fmap function \verb|xmap|, and an algebra \verb|alg|
with that carrier.  It will then call \verb|alg| (after \verb|unroll|ing
it) with implementations for the components of the recursion universe
(cf. Section~\ref{sec:recu}, also Figure~\ref{fig:algf}):
\begin{itemize}
\item \verb|Subrec| is passed as the value for the abstract type \verb|R|; this is what enables all
  the rest of the components to have the desired types, since we will pass values that have \verb|Subrec|
  where the interface mentions \verb|R|.
\item The function \verb|fold : FoldT Alg Subrec| is passed as
  the fold function of type \verb|FoldT Alg R|. 
\item For the \verb|rec : R -> X R| function, we pass \verb|(fold X xmap alg) : Subrec -> X Subrec|.
\item For the subdata structure of type \verb|F R|, we pass \verb|d : F Subrec|. 
\end{itemize}

Finally, Figure~\ref{fig:subrecb} defines \verb|out| as a subsidiary
recursion, given a fold function.
Outside the recursion, \verb|d| has type \verb|F R|; inside the
recursion it has type \verb|F R'| where \verb|R'| is the abstract type
of the subsidiary recursion.  So \verb|out| implements the idea that
unfolding an abstract type one step is just a trivial case of
subsidiary recursion.

\begin{figure}
\begin{minted}{coq}
Definition fold : FoldT Alg Subrec := 
  fun X FunX alg d => unroll d X FunX alg.

Definition inn : F Subrec -> Subrec :=
  fun d => roll (fun X xmap alg =>
                 unrollAlg alg Subrec fold (fold X xmap alg) d).

Definition out{R:Set}(fo:FoldT Alg R) : R -> F R :=
  fo F FunF (rollAlg (fun R' _ _ d => d)).
\end{minted}
\caption{The rest of the interface for \texttt{Subrec} (\texttt{Subrec.v})}
\label{fig:subrecb}
\end{figure}


\section{Interface for subsidiary induction (\texttt{Subreci.v})}
\label{sec:interfacei}

We have seen how to write subsidiary recursions in Coq.  But can one
reason about these?  To wrap up this paper, we will briefly see the
interface to our development of subsidiary induction in Coq, and
example proofs written using this interface.  Subsidiary induction is
the natural extension of subsidiary recursion, which worked over
\verb|Set|s, to \verb|Subrec|-predicates.  The development is
parametrized by a functor \verb|F| and a functor
\verb|Fi : (Subrec -> Prop) -> (Subrec -> Prop)| over
\verb|Subrec|-indexed propositions (i.e., predicates).  Just as
functors need an \verb|fmap| function, we here need an indexed
version, of type \verb|fmapiT Subrec Fi| (definition elided.)

The central definitions for the type \verb|Subreci : Subrec -> Prop|
are given in Figure~\ref{fig:subreci}.  Where having a value \verb|x|
of \verb|Subrec| entitles us to define subsidiary recursions to
inhabit types \verb|X Subrec|, a value of type \verb|Subreci x| lets
us prove properties of \verb|x| by subsidiary induction.  Briefly:
\verb|kMo| is the kind for \emph{motives}, namely predicates on
\verb|Subrec|~\cite{mcbride00}.  \verb|KAlgi| is the kind for indexed
algebras.  \verb|FoldTi| is the indexed version of \verb|FoldT|: it 
expresses provability of \verb|X C| for \verb|d|, based on an indexed
algebra and a value of type \verb|C d|, where \verb|C| is the (indexed) anchor
type.  \verb|AlgFi| and \verb|Algi| are indexed versions
of the algebras we saw for recursion.  The \verb|rec| function
(Figure~\ref{fig:algf}) has now become an induction hypothesis: given
any \verb|d| where \verb|R d| holds, \verb|ih| proves \verb|X R d|.  A
value of type \verb|R d| is thus a license to induct on \verb|d|.
Finally, the algebra is given a subdata structure indexed by
\verb|d : Subrec|, and must produce a proof of \verb|X R d|.  \verb|Subreci|
is defined as the suitably indexed fixed-point of \verb|SubrecFi|, which
is the natural indexed version of \verb|SubrecF|.


\begin{figure}
\begin{minted}{coq}
Definition kMo := Subrec -> Prop.
Definition KAlgi := (kMo -> kMo) -> Set.
Definition FoldTi(alg : KAlgi)(C : kMo) : kMo :=
  fun d => forall (X : kMo -> kMo) (xmap : fmapiT Subrec X), 
           alg X -> C d -> X C d.

Definition AlgFi(A: KAlgi)(X : kMo -> kMo) : Set :=
  forall (R : kMo)
    (fo : (forall (d : Subrec), FoldTi A R d))
    (ih : (forall (d : Subrec), R d -> X R d))
    (d : Subrec),
    Fi R d -> X R d.

Definition Algi := MuAlgi Subrec AlgFi.

Definition SubrecFi(C : kMo) : kMo := 
  fun d => forall (X : kMo -> kMo) (xmap : fmapiT Subrec X), Algi X -> X C d.
Definition Subreci := Mui Subrec SubrecFi.

Definition foldi(i : Subrec) : FoldTi Algi Subreci i.
Definition inni(i : Subrec)(fd : Fi Subreci i) : Subreci i.
\end{minted}
\caption{Interface for subsidiary induction (\texttt{Subreci.v})}
\label{fig:subreci}
\end{figure}

For lists, we instantiate \verb|Fi| with \verb|ListFi|, shown in
Figure~\ref{fig:listfi}.  This is just the indexed version of
\verb|ListF|.  Given a \verb|list A|, \verb|toListi| returns
a value of type \verb|Listi (toList xs)|.  This can be understood
as saying that for any list (from Coq's standard library),
we can reason by subsidiary induction to prove properties of \verb|toList xs|.
We also introduce an abbreviation \verb|ListFoldTi| for the type
of indexed fold functions over lists.

\begin{figure}
\begin{minted}{coq}
Definition lkMo := List -> Prop.

Inductive ListFi(R : lkMo) : lkMo :=
  nilFi : ListFi R mkNil
| consFi : forall (h : A)(t : List), R t -> ListFi R (mkCons h t).

Definition Listi := Subreci ListF ListFi.
Definition toListi(xs : list A) : Listi (toList xs) := listFoldi xs Listi inni.
Definition ListFoldTi(R : List -> Prop)(d : List) : Prop :=
  FoldTi ListF (Algi ListF ListFi) R d.
\end{minted}
\caption{The indexed version \texttt{ListFi} of \texttt{ListF} (\texttt{List.v})}
\label{fig:listfi}
\end{figure}

\section{Examples of subsidiary induction}
\label{sec:examplesi}

For proving the main theorem about run-length encoding, we need
several lemmas about \verb|span|, shown in Figure~\ref{fig:spanlem}.
For lack of space, we just state the properties.  The first says that
appending the results of a call to span returns the original list
(module some conversions to \verb|list| from \verb|List|).  The second
uses the inductive type \verb|Forall| from Coq's standard library to
state that all the elements of the prefix returned by \verb|span|
satisfy \verb|p|.  These lemmas are proved using indexed algebras with
constant (indexed) carriers.  In contrast, \verb|GuardPresF| uses its
argument \verb|S| to express that whenever \verb|spanh| returns a
suffix \verb|r|, that suffix satisfies \verb|S|.  This enables us to
invoke an outer induction hypothesis on this suffix, when reasoning
subsidiarily about \verb|span|.  Using these lemmas, we can write a
short proof by subsidiary induction of the following, where
\verb|rld : list (nat * A) -> list A| is the obvious decoding
function:

\begin{minted}{coq}
Theorem RldRle (xs : list A): rld (rle (toList xs)) = xs.  
\end{minted}

\noindent We invoke the lemmas about \verb|span| subsidiarily,
so that we may apply our induction hypothesis to the suffix
that \verb|span| returns (on which \verb|mapThrough| then recurses).
For example, the lemma for \verb|GuardPresF| takes in the
indexed fold function \verb|foi| from the outer induction (for \verb|RldRle|),
to show that the abstract predicate \verb|R| applies to the suffix
\verb|r| returned by \verb|span|.  This enables the outer induction
hypothesis (for \verb|RldRle|) to be applied.

\begin{minted}{coq}
Lemma guardPres{R : List A -> Prop}(foi:forall d : List A, ListFoldTi R d)
      (p : A -> bool)(xs : List A)(rxs : R xs)
      (l:list A)(r : List A)(e: span p xs = (l,r)) : R r.
\end{minted} 

\begin{figure}
\begin{minted}{coq}
Definition SpanAppendF(p : A -> bool)(xs : List A) : Prop :=
  forall (l : list A)(r : List A) ,
    span p xs = (l,r) ->
    fromList xs = l ++ (fromList r).

Definition spanForallF(p : A -> bool)(xs : List A) : Prop :=
  forall (l : list A)(r : List A),
    span p xs = (l,r) ->
    Forall (fun a => p a = true) l.

Definition GuardPresF(p : A -> bool)(S : List A -> Prop)(xs : List A) : Prop :=
  forall (l : list A)(r : List A),
    spanh p xs = SpanSomeMatch l r ->
    S r.
\end{minted}
\caption{Statements of three lemmas about \texttt{span} (directory \texttt{SpanPfs})}
\label{fig:spanlem}
\end{figure}

Finally, as promised, a note on noncanonicity. When proving properties about subsidiary
recursions on \verb|xs : List A|, one should be aware that nothing prevents
the property from being applied to noncanonical \verb|List|s.  For example,
suppose we wish to prove that if all elements of a  list satisfy \verb|p|, then
the suffix returned by \verb|span| is empty.  It is dangerous to phrase
this as ``the suffix equals \verb|mkNil|'', because for a noncanonical input \verb|xs|,
\verb|span| will return that same  noncanonical \verb|xs| as the suffix (and so
it may be a noncanonical empty list, not equal to \verb|mkNil|).  The solution
in this case is to use a function \verb|getNil| (\verb|List.v|) that computes
an empty list from \verb|xs|.  The statement that one can prove is shown in Figure~\ref{fig:spanforallt}.

\begin{figure}
\begin{minted}{coq}
Definition spanForall2F(p : A -> bool)(xs : List A) : Prop :=
  Forall (fun a => p a = true) (fromList xs) ->
  span p xs = (fromList xs, getNil xs).
\end{minted}
\caption{A statement of the property that \texttt{span} returns the empty suffix, computed using \texttt{getNil} to avoid noncanonicity problems, if all elements satisfy \texttt{p}}
\label{fig:spanforallt}
\end{figure}

\section{Related Work}
\label{sec:related}

\textbf{Termination.}  In some tools, like Coq, Agda, and Lean,
termination is checked statically, based on structural decrease.
Others, like Isabelle/HOL, allow one to write recursions first, and
prove (possibly with automated help) their termination
afterwards~\cite{krauss}.  These tools all support well-founded
recursion, but in constructive type theory, evidence of
well-foundedness then propagates through code.  In contrast, our
approach here, while less general, does not clutter code with proofs.
Subsidiary recursion can be seen as a generalization of \emph{nested
recursion}, which allows recursive calls of the form
\verb|f (f x)|~\cite{krauss10}.  In subsidiary recursion, these are
generalized to the form \verb|f (g x)|, where \verb|g| could be
\verb|f| or another recursively defined function.  For more on
partiality and recursion in theorem provers, see~\cite{bove+16}.

Our work contributes to the program proposed by Owens and Slind, of
broadening the scope of functional programs that can be accommodated
in ITPs~\cite{owens+08}.  The goal of terminating recursion has been
advocated in the literature on programming languages under the name
\emph{strong functional programming}~\cite{turner95}.  Our method is
similar to the technique of sized types, in providing a type-based
method for termination~\cite{barthe04}.  With sized types, datatypes
are indexed with abstract sizes, which must then be propagated through
code, using dependent types.  In contrast, our approach relies just on
polymorphism, and does not require dependent types for writing
subsidiary recursions.  (\verb|Subreci|, for reasoning about such
recursions, of course does use dependent types).

Uustalu and Vene developed a categorical view of a recursion scheme
allowing one level of subsidiary recursion, and illustrated it in
Haskell with an artificial example~\cite{uustalu11}.  In contrast, our
scheme allows arbitrary finite nestings of recursion, and we
illustrate it in Coq with realistic examples.  It seems that
generalizing the carriers of algebras to functors is the critical step
enabling such examples. In our Coq development, we show that Uustalu
and Vene's scheme is derivable from subsidiary recursion. 

\textbf{Mendler-style recursion.}  Mendler introduced the idea of
using universal abstraction to support compositional termination
checking~\cite{mendler91}.  He proposed a functor-generic recursor of
type $\all{X}{(\all{R}{(R \to X) \to F\ R \to X}) \to \mu\ F\ \to
  X}$. We have applied this idea to the constructor of the type
\verb|Mu| (Section~\ref{sec:mu}).  Previous work explored the
categorical perspective on Mendler-style recursion, and showed how to
reduce it to basic catamorphisms (i.e., structural
recursion)~\cite{uustalu99}.  Another considered its use with negative
type schemes~\cite{ahn11}.  Previous work from our group showed how to
derive inductive datatypes in Cedille using extensions of the Mendler
encoding~\cite{firsov+18b,firsov+18a}.  Here, we do not derive
inductive types, but rather 
a terminating recursion scheme for existing datatypes.

\section{Conclusion}

We have seen a derivation in Coq of a scheme for terminating
subsidiary recursion, where recursions may be nested and outer
recursive calls may be made on results of inner recursions.  We saw
examples invoking the \verb|span| function as a subsidiary recursion,
for functions \verb|wordsBy| and run-length encoding.  We also looked
briefly at the extension of this interface to support subsidiary
induction, with example lemmas about \verb|span|, and the decoding
correctness theorem for run-length encoding.  There are many other
interesting examples we can develop in Coq with this interface,
including natural-number division, which may invoke subtraction as a
subsidiary recursion.  Another example is Harper's regular-expression
matcher, which previous work showed can be implemented in Cedille
using a form of nested recursion that is subsumed by subsidiary
recursion~\cite{stump20}.  We may also attempt to extend the recursion
universe further, to allow other forms of recursion like
divide-and-conquer, where some (necessarily limited) ability to
recurse on values built using constructors is required.

\pagebreak
\bibliography{biblio}

\end{document}
