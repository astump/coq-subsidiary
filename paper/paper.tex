
\documentclass[a4paper,USenglish]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Subsidiary Recursion in Coq} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Aaron Stump}{Computer Science Dept., The University of Iowa, USA \and \url{http://www.cs.uiowa.edu/~astump/}}{aaron-stump@uiowa.edu}{http://orcid.org/0000-0002-9720-0003}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Alex Hubers}{Computer Science, The University of Iowa, USA}{alexander-hubers@uiowa.edu}{}{}

\author{Christopher Jenkins}{Computer Science, The University of Iowa, USA}{alexander-hubers@uiowa.edu}{http://orcid.org/
0000-0002-5434-5018}{}

\author{Benjamin Delaware}{Computer Science, Purdue University, USA \and \url{https://www.cs.purdue.edu/homes/bendy/}}{bendy@purdue.edu}{}{}

\authorrunning{A. Stump, A. Hubers, C. Jenkins, and B. Delaware} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Aaron Stump, Alex Hubers, Christopher Jenkins, and Benjamin Delaware} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{Software and its engineering~Recursion}
\ccsdesc[100]{Software and its engineering~Polymorphism}

\keywords{strong functional programming, recursion schemes, positive-recursive types, impredicativity} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{June Andronick and Leonardo da Moura}
\EventNoEds{2}
\EventLongTitle{Interactive Theorem Proving 2022}
\EventShortTitle{ITP 2022}
\EventAcronym{ITP}
\EventYear{2022}
\EventDate{2022}
\EventLocation{}
\EventLogo{}
\SeriesVolume{}
\ArticleNo{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\all}[2]{\forall\, #1.\, #2}


\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
  This paper describes a functor-generic derivation in Coq of
  subsidiary recursion.  On this recursion scheme, inner recursions
  may be initiated within outer ones, in such a way that outer
  recursive calls may be made on results from inner ones.  The
  derivation utilizes a novel (necessarily weakened) form of
  positive-recursive types in Coq, dubbed retractive-positive
  recursive types.  A corresponding form of induction is also
  supported.  The method is demonstrated through several examples.
\end{abstract}

\section{Introduction: subsidiary recursion}
\label{sec:intro}

Central to interactive theorem provers like Coq, Agda, Isabelle/HOL,
Lean and others are terminating recursive functions over user-declared
inductive datatypes~\cite{agda,coq,isabelle-hol,lean}.  Termination is
usually enforced by a syntactic check for structural decrease, which
is sufficient for many basic functions.  For example, the
\texttt{span} function from Haskell's prelude (\verb|Data.List|) takes
a list and returns a pair of the maximal prefix whose elements satisfy
a given predicate \verb|p|, and the remaining suffix:
\begin{verbatim}
span :: (a -> Bool) -> [a] -> ([a],[a])
span _ []    =  ([], [])
span p (x:xs) = if p x
                then let (ys,zs) = span p xs in (x:ys,zs)
                else ([],x:xs)
\end{verbatim}
\noindent The sole recursive call is \verb|span p xs|, and it occurs
in a clause where the input list is of the form \verb|x:xs|.  Hence it
is structurally decreasing.  In the appropriate syntax, this
definition can be accepted without additional effort by all the
mentioned provers.

This paper is about a more expressive form of terminating recursion,
called \textbf{subsidiary recursion}.  While performing an outer
recursion on some input \verb|x|, one may initiate an inner recursion
on \verb|x| (or possibly some of its subdata), preserving the
possibility of further invocations of the outer recursive function.
Let us see a simple example.  The function \verb|wordsBy|
(\verb|Data.List.Extra|) breaks a list into its maximal sublists whose
elements do not satisfy a predicate \verb|p|.  For example,
\verb|wordsBy isSpace " good day "| returns \verb|["good","day"]|.
Code is in Figure~\ref{fig:wordsBy}.  Recall that
\verb|break p| is equivalent to \verb|span (not . p)|. The first recursive call,
\verb|wordsBy p tl|, is structural.  But in the second, we invoke
\verb|wordsBy p| on a value obtained from another recursion, namely
\verb|span|.  This is not allowed under structural termination, but
will be permitted by subsidiary recursion.

\begin{figure}
\begin{verbatim}
wordsBy :: (a -> Bool) -> [a] -> [[a]]
wordsBy p [] = []
wordsBy p (hd:tl) =
  if p hd
  then wordsBy p tl 
  else let (w,z) = break p tl in
        (hd:w) : wordsBy p z
\end{verbatim}
\caption{Haskell code for \texttt{wordsBy}, demonstrating subsidiary recursion}
\label{fig:wordsBy}
\end{figure}

\subsection{Summary of results}

This paper presents a functor-generic derivation of terminating
subsidiary recursion and induction in Coq.  We should emphasize that
this is a derivation within the type theory of Coq, and requires no
axioms or other modifications to Coq. Using this derivation, we
present several example functions like \verb|wordsBy|, and prove
theorems about them.  A nice example is a definition of run-length
encoding using \verb|span| as a subsidiary recursion, where we prove
that encoding and then decoding returns the original list.  Our
approach applies to the standard datatypes in the Coq library, and
does not require switching libraries or datatype definitions.

An important technical novelty is a derivation of a weakened form of
positive-recursive type in Coq.  Coq (Agda, and Lean) restrict
datatypes $D$ to be strictly positive: in the type for any constructor
of $D$, $D$ cannot occur to the left of any arrows.  Our derivation
needs to use positive-recursive types, where $D$ may occur to the left
of an even number (only) of arrows.  We present a way to derive a
weakened form of positive-recursive type that is sufficient for our
examples (Section~\ref{sec:mu}).  The weakening is to require only
that $F\ \mu$ is a retract of $\mu$, where $\mu$ is the recursive type
and $F\ \mu$ its one-step unfolding.  Usually these types are
isomorphic.  Hence, we dub these \textbf{retractive-positive}
recursive types.  This weakening leads to noncanonical elements of
$\mu$, but we will see how to work around this.  Our definition of
retractive-positive recursive types makes essential use of impredicate
quantification, and hence is not available in predicative theories
like Agda's.

We begin by summarizing the interface our derivation provides for
subsidiary recursion (Section~\ref{sec:interface}), and then see
examples (Section~\ref{sec:examples}).  We next explain how the
interface is actually implemented (Section~\ref{sec:deriv}), including
our retractive-positive recursive types (Section~\ref{sec:mu}).  The
interface for subsidiary induction is covered next
(Section~\ref{sec:interfacei}), and example proofs using it
(Section~\ref{sec:examplesi}).  Related work is discussed in
Section~\ref{sec:related}.

All presented derivations have been checked with Coq version 8.13.2,
using command-line option \verb|-impredicative-set|.  The code may be
found as release \verb|itp-2022| (dated prior to the ITP 2022
deadline) at \url{https://github.com/astump/coq-subsidiary}.  The
paper references files in this codebase, as an aid to the reader
wishing to peruse the code.

\section{Interface for subsidiary recursion}
\label{sec:interface}

This section presents the interface our Coq development provides
for subsidiary recursion.

\subsection{The recursion universe}
\label{sec:recu}

Our approach is within a long line of work using ideas from universal
algebra and category theory to describe inductive datatypes and their
recursion principles.  On this approach, one describes transformations
to be performed on data as \emph{algebras}, which can then be
\textit{folded} over data.  The simplest form of algebras, namely
$F$-algebras, are morphisms from $F\ A$ to $A$, for carrier object
$A$.  From a programming perspective, an $F$-algebra is given input of
type $F\ A$, and must compute a result of type $A$.

Algebras for our subsidiary recursion are more complex.  First, for
reasons we will explain further below, the carrier of the algebra will
be a functor \verb|X : Set -> Set|.  Second, algebras have a specified
\emph{anchor type} \verb|C|, which we can think of as the datatype
\emph{as viewed by a containing recursion} or else, if this is a
top-level recursion, our development's version of the actual datatype
(e.g., \verb|List|).  The algebra is presented with:

\begin{itemize}
\item a type \verb|R : Set|, which will be this recursion's view of the datatype.
\item a function \verb|reveal : R -> C|, which reveals values of type \verb|R| as really having the anchor type.  
\item a function \verb|fold : FoldT Alg R|, which allows one to initiate subsidiary recursions in which the anchor type is \verb|R|.  Note that the algebra's anchor type is \verb|C|, but for subsidiary recursions the anchor type changes (to \verb|R|). We will present the type \verb|FoldT Alg R| below.
\item a function \verb|eval : R -> X R|, to use for making recursive calls, on any value of type \verb|R|.
\item and a \emph{subdata structure} \verb|d : F R|, where \verb|F| is the signature functor for the datatype.
\end{itemize}

\noindent The algebra is then required to produce a value of type \verb|X R|.

We will use Coq inductive types for the signature functors \verb|F| of
various datatypes, thus enabling recursions to use Coq's
pattern-matching on the subdata structure \verb|d|.  So the style of
coding against this interface retains a similar feel to structural
recursion.  Unlike with structural termination, though, the interface
here is type-based and hence compositional.  

As in previous work, we dub this interface a \emph{recursion
universe}~\cite{stump20}.  As in other domains using the term
``universe'', we have an entity (here, \verb|R|) from which one cannot
escape by using the available operations (for other cases:
the ordinal $\epsilon_0$ and $\omega^-$, the physical universe and traveling at
the speed of light).  Staying in the recursion universe is good,
because we may recurse (via \verb|eval|) on any value of type
\verb|R|.  Some points must still be explained: why \verb|X| has type \verb|Set -> Set|,
and the definition of \verb|FoldT|.  Let us see these details next.

\subsection{The interface in more detail}

Let us consider two central files from our development.

\begin{figure}
  \begin{verbatim}
Inductive ListF(X : Set) : Set :=
| Nil : ListF X
| Cons : A -> X -> ListF X.

Definition List := Subrec ListF .
Definition inList : ListF List -> List := inn ListF.
Definition mkNil : List := inList Nil.
Definition mkCons (hd : A) (tl : List) : List := inList (Cons hd tl).
Definition toList : list A -> List.
Definition fromList : List -> list A.
\end{verbatim}
  \caption{Some basics from \texttt{List.v}, specializing the functor-generic derivation of subsidiary recursion to lists (\texttt{List.v})}
  \label{fig:listf}
\end{figure}

\subsubsection{Subrec.v}

  This file is parametrized by a signature functor \verb|F| of type
  \verb|Set -> Set|.  It provides the implementation of subsidiary
  recursion.  Two crucial values are \verb|Subrec : Set|, which is the
  type to use for subsidiary recursion; and
  \verb|inn : F Subrec -> Subrec|, which is to be used as a
  constructor for that type.  An important point, however, is that
  \verb|Subrec.v| does not provide an induction principle based on
  \verb|inn|.  Induction is derived later
  (Section~\ref{sec:interfacei}). \verb|Subrec.v| makes critical use
  of retractive-positive recursive types, to take a fixed-point of a
  construction based on \verb|F|.  We present these recursive
  types in Section~\ref{sec:mu} below.

  \subsubsection{List.v}

  This file specializes the development in \verb|Subrec.v| to the case
  of lists (parametrized by the type \verb|A| of elements).  In
  general, to use our development to get subsidiary recursion over
  some datatype, one will have a similar ``shim'' file.  For space
  reasons, we just give the example of lists.  The file defines the
  signature functor \verb|ListF|, shown in Figure~\ref{fig:listf}.  We
  then define \verb|List| to be \verb|Subrec|, with the instantiation
  of \verb|F| to \verb|ListF A|.  This type \verb|List| is not to be
  confused with the type \verb|list| of lists in Coq's standard
  library.  As noted previously, our development is meant to be used
  in extension of existing inductive datatypes, not replacing them.
  The figure also shows constructors \verb|mkNil| and \verb|mkCons|
  for \verb|List|, and types for conversion functions between
  \verb|List| and \verb|list|; one direction uses Coq's structural
  recursion, the other uses our subsidiary recursion (code elided).
  

\subsection{Algebras for subsidiary recursion}

\verb|Subrec.v| also defines the notion of algebra that is used for
writing recursions.  The central definitions are in
Figure~\ref{fig:algf}.  \verb|KAlg| is the kind for the
type-constructor for algebras, as we see in the definition of
\verb|Alg|.  This type-constructor \verb|Alg| is a fixed-point of the
type \verb|AlgF|.  The fixed-point is taken using \verb|MuAlg|, which
implements our retractive-positive recursive types
(Section~\ref{sec:mu}) at kind \verb|KAlg|.  Using \verb|Alg| will
require that \verb|AlgF| only uses its parameter \verb|Alg|
positively.  We will confirm this shortly.

\begin{figure}
\begin{verbatim}
Definition KAlg  : Type := Set -> (Set -> Set) -> Set.

Definition FoldT(alg : KAlg)(C : Set) : Set :=
  forall (X : Set -> Set) (FunX : Functor X), alg C X -> C -> X C.

Definition AlgF(Alg: KAlg)(C : Set)(X : Set -> Set) : Set :=
  forall (R : Set)
         (reveal : R -> C)        
         (fold : FoldT Alg R)
         (eval : R -> X R)      
         (d : F R),             
         X R.

Definition Alg : KAlg := MuAlg AlgF.

Definition fold : FoldT Alg Subrec.
Definition rollAlg :
  forall {C : Set} {X : Set -> Set}, AlgF Alg C X -> Alg C X.
Definition unrollAlg : 
  forall {C : Set} {X : Set -> Set}, Alg C X -> AlgF Alg C X.
\end{verbatim}
\caption{The type for algebras (\texttt{Subrec.v})}
\label{fig:algf}
\end{figure}

\verb|FoldT Alg C| is the type for fold functions which apply
algebras of type \verb|Alg| to data of type \verb|C|, which we have
already dubbed the \emph{anchor type} of the recursion.  At the top
level of code, the anchor type would just be \verb|List| (for
example).  When one initiates a subsidiary recursion, though, the
anchor type will instead by the abstract type \verb|R| for the outer recursion.
The variable \verb|Alg| occurs only positively (but not strictly
positively) in \verb|AlgF|, because it occurs negatively in
\verb|FoldT Alg R| which occurs negatively in \verb|AlgF Alg C X|.  So
we can indeed take a fixed-point of \verb|AlgF| to define the constant
\verb|Alg|.

Let us look at \verb|AlgF|.  As noted already, each recursion is based
on an abstract type \verb|R|, representing the data upon which we will
recurse.  This is the first argument to a value of type
\verb|AlgF Alg C X|.  An algebra can assume nothing about \verb|R|
except that it supports the following operations.  First there is
\verb|reveal|, which turns an \verb|R| into a \verb|C|.  This reveals
that the data of type \verb|R| are really values of the anchor type
of this recursion.  Next we have \texttt{fold}, which will allow us to fold
another algebra over data of type \verb|R|.  We will use \verb|fold|
to initiate subsidiary recursions.  Then there is \verb|eval|, for
recursive calls on data of type \verb|R|.

As noted already, for subsidiary recursion, algebras have a carrier
\verb|X| which depends (functorially) on a type.  This is so that (i)
inside an inner recursion we may compute a result of some type that
may mention \verb|R|, but (ii) outside that recursion, the result will
mention the anchor type \verb|C|.  The \verb|eval| function returns
something of type \verb|X R|, and so does the algebra itself; this
demonstrates (i).  For (ii): if we look at the definition of
\verb|FoldT| in the figure, we see that folding an algebra of type
\verb|alg C X| over a value of type \verb|C| produces a result of type
\verb|X C|.  Having a functor for the carrier of the algebra gives us
the flexibility to type results inside a recursion with the abstract
type \verb|R|, but view those results as having the anchor type
\verb|C| outside the recursion.

The final definitions in the figure are for \verb|fold|, which allows
us to fold an \verb|Alg| over a value of type \verb|Subrec|; and for mapping
between \verb|Alg| and its unfolding in terms of \verb|AlgF|.  We will
return to the code for \verb|Subrec.v| in Section~\ref{sec:deriv}.

\section{Examples of subsidiary recursion}
\label{sec:examples}

Having seen the interface for subsidiary recursion in Coq, let us
consider now some examples.

\subsection{The \texttt{span} function (\texttt{Span.v})}

Given a predicate \verb|p : A -> bool|, and a value of type
\verb|List A|, we would like to compute a pair of type
\verb|list A * List A|, where the first component is the maximal
prefix whose elements satisfy \verb|p|, and the second is the
remaining suffix.  This is the typing for a top-level recursion.  More
generally, though, given an anchor type \verb|R : Set| along with a
fold function for that anchor type (i.e., of type \verb|FoldT (Alg (ListF A)) R|),
we would like to map an input list of type \verb|R| to a pair of
type \verb|list A * R|.  The first component of this pair is
going to be built up from scratch, and so cannot have type \verb|R|;
we cannot statically ensure that outer recursions on it are legal.
But the second component will be a subdatum of the input list,
and so can still have type \verb|R|, enabling outer recursive calls.  So we want: 
\begin{verbatim}
Definition spanr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                (p : A -> bool)(xs : R) : list A * R.
\end{verbatim}
\noindent From this we can also define the top-level recursion, by
supplying \verb|fold (ListF A)|, which is the function for folding an algebra
over a list (Figure~\ref{fig:algf}), for the argument \verb|fo| of \verb|spanr|:
\begin{verbatim}
Definition span(p : A -> bool)(xs : List A) : list A * List A
  := spanr (fold (ListF A)) p xs.
\end{verbatim} 

Before we define \verb|spanr|, we must resolve a small problem.
If the first element of the input list
\verb|xs| to \verb|span| does not satisfy \verb|p|, then \verb|span|
should return \verb|([], xs)|.  But when recursing on \verb|xs|, we
will see it only in the form of a subdata structure of type
\verb|F R|.  We will not be able to return it from our recursion at
type \verb|R|, and hence we would not be able to return \verb|([],xs)|
as desired.  To work around this, we will have our recursion return a value
of type \verb|SpanF R| (\verb|X| will be implicit for the constructors):
\begin{verbatim}
Inductive SpanF(X : Set) : Set :=
  SpanNoMatch : SpanF X
| SpanSomeMatch : list A -> X -> SpanF X.
\end{verbatim}
\noindent The idea is that the recursion will signal if it is in the
one tricky case where \verb|p| does not match the first element, by
returning \verb|SpanNoMatch|.  Otherwise, it will be able to return,
via \verb|SpanSomeMatch|, a prefix and the suffix at type
\verb|R|. The prefix will be nonempty, and hence the suffix will be at
most the tail of \verb|xs|.  This tail is available to the algebra
in the subdata structure of type \verb|F R|.

\begin{figure}
\begin{verbatim}
Definition SpanAlg(p : A -> bool)(C : Set)
  : Alg (ListF A) C SpanF :=
  rollAlg (fun R reveal fo span xs => 
     match xs with
         Nil => SpanNoMatch 
       | Cons hd tl =>
          if p hd then
            match (span tl) with
              SpanNoMatch => SpanSomeMatch [hd] tl
            | SpanSomeMatch l r => SpanSomeMatch (hd::l) r
            end
          else
            SpanNoMatch 
       end).
\end{verbatim}
\caption{The algebra \texttt{SpanAlg} for the \texttt{span} function}
\label{fig:spanalg}
\end{figure}

Figure~\ref{fig:spanalg} gives the algebra \verb|SpanAlg| for computing
\verb|span|.  The type of \verb|SpanAlg p C| is
\begin{verbatim}
Alg (ListF A) C SpanF
\end{verbatim}
This states that we are defining an algebra (\verb|Alg|) for the
\verb|ListF A| functor, with anchor type \verb|C| and carrier
\verb|SpanF|.  \verb|SpanF| has type \verb|Set -> Set|, as required
for the carriers of our algebras. The definition of \verb|SpanAlg| is
actually parametrized by \verb|C|, which is good, as it means we can
use \verb|SpanAlg| for top-level or subsidiary recursions.

Let us continue through the code for \verb|SpanAlg|
(Figure~\ref{fig:span}).  We use \verb|rollAlg| to create an algebra
from something whose type is an application of \verb|AlgF|.  This
takes in all the components of the recursion universe: the abstract
type \verb|R|, the \verb|reveal| function (not needed in this case),
the fold function (\verb|fo|) for any subsidiary recursions (also not
needed here), a function we choose to name \verb|span| for making
recursive calls, and finally \verb|xs : ListF A R|.  The algebra
pattern-matches on this \verb|xs|.  In the cases where it is empty or
where its head (\verb|hd|) does not satisfy \verb|p|, we return
\verb|SpanNoMatch|.  This signals to the caller that we really wished
to return \verb|([],xs)|, but could not because we do not have
\verb|xs| at type \verb|R|.  If the head does satisfy \verb|p|, then
we recurse on the tail (\verb|tl : R|) by calling the provided \verb|span : R -> SpanF R|.
If \verb|span tl|
returns \verb|SpanNoMatch|, that means that we should make \verb|tl|
the suffix in the pair we return (via \verb|SpanSomeMatch|).  Happily,
we have \verb|tl : R| here, so we can do this.  In either case (for
return value of \verb|span tl|), we add the head to the front of the
prefix.

\verb|SpanAlg| is used in the definition of \verb|spanhr|, in
Figure~\ref{fig:span}.  This function invokes the fold function it is
given, on \verb|SpanAlg|.  The final twist is now in the definition of
\verb|spanr|.  We call \verb|spanhr| on the input \verb|xs : R|.  If
\verb|spanhr| returns \verb|SpanNoMatch|, then we are supposed to
return \verb|([],xs)|, which we can do here, because we have
\verb|xs : R|.  It was only inside the algebra that we lost the
information that the subdata structure of type \verb|F R| is derived
from a value of type \verb|R|.  If \verb|spanhr| returns
\verb|SpanSomeMatch|, then the return value gives us the nonempty
prefix (\verb|l|) and the suffix (\verb|r|), which we then return.  We
also define a version of \verb|break| for subsidiary recursion.


\begin{figure}
\begin{verbatim}
Definition spanhr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                 (p : A -> bool)(xs : R) : SpanF R :=
  fo SpanF SpanFunctor (SpanAlg p R) xs.

Definition spanr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                (p : A -> bool)(xs : R) : list A * R
  := match spanhr fo p xs with
       SpanNoMatch => ([],xs)
     | SpanSomeMatch l r => (l,r)
     end.

Definition breakr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                 (p : A -> bool)(xs : R) : list A * R :=
  spanr fo (fun x => negb (p x)) xs.
\end{verbatim}
\caption{Functions derived from \texttt{SpanAlg}}
\label{fig:span}
\end{figure}


\subsection{The \texttt{wordsBy} function (\texttt{WordsBy.v})}

Let us now see how to write \verb|wordsBy|, our example function from
Section~\ref{sec:intro}, using \verb|breakr| subsidiarily.
The code is in Figure~\ref{fig:wordsby}, assuming a type
\verb|A : Set|.  The setup is similar to that for \verb|span|.  We first define
an algebra \verb|WordsBy|, parametrized by anchor type \verb|C| (and also
the predicate \verb|p|), of type
\begin{verbatim}
Alg (ListF A) C (Const (list (list A)))
\end{verbatim}
\noindent This says that \verb|WordsBy p C| is an algebra (\verb|Alg|)
for the \verb|ListF A| functor, with anchor type \verb|C|, and carrier
\verb|Const (list (list A))|.  \verb|Const| is the combinator for
creating the object part of constant functors; \verb|FunConst| creates
the morphism part (i.e., the \verb|fmap| function).  We use 
\verb|Const| where the return type of the
algebra will not depend on its abstract type \verb|R|.  Here, we are
constructing from scratch a list of lists, so it will not be legal to
recurse on the list itself, or its (list) elements.  So we just
use the \verb|list| type of Coq's standard library.

The code for \verb|WordsBy| is, except for the noise of \verb|rollAlg|
and accepting the components of the recursion universe, essentially
the same as what we saw in Section~\ref{sec:intro}.  We pattern match
on \verb|xs : ListF A R|.  Recall that for this function, we are
trying to drop elements which satisfy \verb|p|, and return a list of
the sublists between maximal sequences of such elements.  In the
\verb|Cons| case, if the head (\verb|hd|) satisfies the predicate, then we are
supposed to drop it and recurse.  This is legal, because \verb|tl : R|
and \verb|wordsBy : R -> list (list A)|.  In the \verb|else| case,
we use \verb|breakr| to obtain the maximal prefix \verb|w| of \verb|tl| that
does not satisfy \verb|p|, and the remaining suffix \verb|z|.

Here we see the benefit of our approach.  From Figure~\ref{fig:span},
the return type of \verb|breakr| is \verb|list A * R|, where \verb|R|
is the anchor type of the provided fold function \verb|fo|.  And
\verb|fo| has type \verb|FoldT (ListF A) Alg R|, from the definition
of \verb|AlgF| in Figure~\ref{fig:algf} (instantiating the functor
with \verb|ListF A|).  This means that from the invocation of
\verb|breakr|, we get \verb|w : list A| and \verb|z : R|.  And so we
can indeed apply \verb|wordsBy : R -> list (list A)| to
\verb|z| to recurse.

\begin{figure}
\begin{verbatim}
  Definition WordsBy(p : A -> bool)(C : Set)
    : Alg (ListF A) C (Const (list (list A))) :=
    rollAlg (fun R reveal fo wordsBy xs => 
         match xs with
           Nil => [] 
         | Cons hd tl =>
           if p hd then
             wordsBy tl
           else
             let (w,z) := breakr fo p tl in
             (hd :: w) :: wordsBy z
         end).

Definition wordsByr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                   (p : A -> bool)(xs : R) : list (list A) :=
  fo (Const (list (list A))) (FunConst (list (list A))) (WordsBy p R) xs.

Definition wordsBy(p : A -> bool)(xs : List A) : list (list A) :=
  wordsByr (fold (ListF A)) p xs.
\end{verbatim}
\caption{The \texttt{wordsBy} and \texttt{wordsByr} function, defined using an algebra}
\label{fig:wordsby}
\end{figure}

\subsection{The \texttt{mapThrough} function (\texttt{MapThrough.v})}

\begin{figure}
\begin{verbatim}
mapThrough :: (a -> [a] -> (b, [a])) -> [a] -> [b]
mapThrough f [] = []
mapThrough f (a:as) = b : mapThrough f as'
    where (b, as') = f a as
\end{verbatim}
\caption{The \texttt{mapThrough} function in Haskell}
\label{fig:mapthroughhs}
\end{figure}

The Haskell library \verb|Data.List.Extra| has a function
\verb|repeatedly|, defined essentially as in
Figure~\ref{fig:mapthroughhs}. We attempt a more informative
name.  This is like the standard \verb|map| function on lists, except
that the function \verb|f| that we are mapping (or ``mapping
through'') takes in not just the current element \verb|a|, but also
the tail \verb|as|.  It then returns the value \verb|b| to include in
the output list, and whatever other list it wishes, upon which
\verb|mapThrough| will recurse.

To write this combinator using our infrastructure for subsidiary
recursion, we need to supply the mapped function with the fold
function for \verb|mapThrough|'s recursion.  This is so that the
mapped function can initiate a subsidiary recursion, returning a value
in the abstract type \verb|R| of \verb|mapThrough|'s recursion.  So
the type we will use for mapped functions is:
\begin{verbatim}
Definition mappedT(A B : Set) : Set :=
  forall(R : Set)(fo:FoldT (Alg (ListF A)) R), A -> R -> B * R.
\end{verbatim}
\noindent This type is more informative than the Haskell type,
since it shows that the second component of the returned value
must have type \verb|R|, and hence must be (hereditarily) a tail
of the input.

Given this definition, the code is in Figure~\ref{fig:mapthrough}.  
\verb|MapThroughAlg| is very similar (discounting syntax) to the
Haskell code above.  Here, though, when we call \verb|f|, we must
supply the abstract type \verb|R| and fold function \verb|fo|.  Then,
from the definition of \verb|mappedT|, we have that \verb|b : B| and
\verb|c : R|.  So we may indeed invoke \verb|mapThrough : R -> list B|
on \verb|c|.  Note that as we are building up a new list from scratch
(rather than just extracting some tail of the input list), we just
return \verb|list B|; we cannot perform further subsidiary recursion
on the output.  

\begin{figure}
\begin{verbatim}
Definition MapThroughAlg{B : Set}(f:mappedT A B)
           (C : Set) : Alg (ListF A) C (Const (list B)) :=
  rollAlg (fun R reveal fo mapThrough xs => 
    match xs with
      Nil => []
    | Cons hd tl =>
      let (b,c) := f R fo hd tl in
        b :: mapThrough c
    end).

Definition mapThroughr{R : Set}(fo:FoldT (Alg (ListF A)) R)
                      {B : Set}(f:mappedT A B) : R -> list B.
Definition mapThrough{B : Set}(f:mappedT A B) : List A -> list B.
\end{verbatim}
\caption{The algebra \texttt{MapThroughAlg} defining function \texttt{mapThrough} and \texttt{mapThroughr}; the
  code for those follows the pattern of \texttt{wordsBy} and \texttt{wordsByr} (Figure~\ref{fig:wordsby}), so
  we omit it}
\label{fig:mapthrough}
\end{figure}

\subsection{Run-length encoding (\texttt{Rle.v})}

\begin{figure}
\begin{verbatim}
rle :: Eq a => [a] -> [(Int,a)]
rle = mapThrough compressSpan
  where compressSpan a as =
          let (p,s) = span (== a) as in
            ((1 + length p, a),s)
\end{verbatim} 
\caption{Run-length encoding in Haskell, using \texttt{mapThrough} and \texttt{span}}
\label{fig:rlehs}
\end{figure}

Using \verb|mapThrough|, we can quite concisely implement
\emph{run-length encoding}, a basic data-compression algorithm where
maximal sequences of $n$ occurrences of element $e$ are summarized by
the pair $(n,e)$~\cite{datacomp}.  Haskell code is in Figure~\ref{fig:rlehs}.
Recall that \verb|(== a)| 
tests its input for equality with \verb|a|.  The
\verb|compressSpan| helper function gathers up all elements at the
start of the tail \verb|as| that are equal to the head \verb|a|.  This
prefix is returned as \verb|p|, with the remaining suffix as \verb|s|.
The pair \verb|(1 + length p, a)| is returned to summarize
\verb|a :: p|.  The \verb|mapThrough| combinator then iterates
\verb|compressSpan| through the suffix \verb|s|.

Assuming \verb|A : Set| and an equality test \verb|eqb : A -> A -> bool| on it,
we port this code to our Coq infrastructure in Figure~\ref{fig:rle}.
The function \verb|compressSpan| is written at the type \verb|mappedT A (nat * A)| that
will be required by \verb|mapThrough|.  Unfolding the definition of \verb|mappedT|,
\verb|compressSpan| has type:
\begin{verbatim}
forall(R : Set)(fo:FoldT (Alg (ListF A)) R), A -> R -> (nat * A) * R.
\end{verbatim}
\noindent It will be invoked by the code for \verb|mapThrough| with a
fold function \verb|fo| with anchor type \verb|R|, and then has the
responsibility of mapping the tail at type \verb|R| (second input) to
a result upon which \verb|mapThrough| should recurse (second component
of the output pair).  Then we define an algebra \verb|RleAlg| by
supplying \verb|compressSpan| as the function to map through, to
\verb|MapThroughAlg| (Figure~\ref{fig:mapthrough}).  Following the
pattern seen above, we define function \verb|rle| for top-level
recursions using \verb|fold| (we could also define a subsidiary version
\verb|rler|).



\begin{figure}
\begin{verbatim}
Definition compressSpan : mappedT A (nat * A) :=
  fun R fo hd tl => 
    let (p,s) := spanr fo (eqb hd) tl in
       ((succ (length p),hd), s).

Definition RleCarr := Const (list (nat * A)).
Definition RleAlg(C : Set) : Alg (ListF A) C RleCarr :=
  MapThroughAlg compressSpan C.
Definition rle(xs : List A) : list (nat * A)
  := fold (ListF A) RleCarr (FunConst (list (nat * A))) (RleAlg (List A)) xs.
\end{verbatim}
\caption{The function \texttt{rle} for run-length encoding, and the algebra \texttt{RleAlg} defining it
in terms of \texttt{MapThroughAlg} (Figure~\ref{fig:mapthrough})}
\label{fig:rle}
\end{figure}

\section{Derivation of subsidiary recursion}
\label{sec:deriv}

Let us now consider the implementation of the
interface we have used for the preceding examples.
The first step is our weakened form of positive-recursive
types.

\subsection{Retractive-positive recursive types}
\label{sec:mu}

As we have seen, our definitions require a form of positive-recursive
types, to allow algebras to accept fold functions that themselves
require algebras, and also for the definition of \verb|Subrec| (which
we will see in more detail in the next section).  Full
positive-recursive types are incompatible with Coq's type
theory~\cite{coquand88}.  One can impose some restrictions on large
eliminations which then enable positive-recursive
types~\cite{blanqui05}, but this requires changing the underlying
theory.  Here we take a different approach, exploiting Coq's
impredicative polymorphism.

This is done in a file \verb|Mu.v|, whose central definitions are in
Figure~\ref{fig:mu}.  The development is parametrized by
\verb|F : Set -> Set| which is assumed to have an \verb|fmap| function
(morphism part of the functor) of type
\begin{verbatim}
forall A B : Set, (A -> B) -> F A -> F B
\end{verbatim}
\noindent which satisfies the identity-preservation law for functors:
\begin{verbatim}
fmapId : forall (A : Set)(d : F A), fmap (fun x => x) d = d
\end{verbatim}

\begin{figure}
\begin{verbatim}
  Inductive Mu : Set := 
    mu : forall (R : Set), (R -> Mu) -> F R -> Mu.

  Definition inMu(d : F Mu) : Mu :=
    mu Mu (fun x => x) d.

  Definition outMu(m : Mu) : F Mu :=
    match m with
    | mu A r d => fmap r d
    end.

  Lemma outIn(d : F Mu) : outMu (inMu d) = d.
\end{verbatim}
\caption{Derivation of retractive-positive recursive types}
\label{fig:mu}
\end{figure}  

Let us consider the code in Figure~\ref{fig:mu}.  The critical
idea is embodied in the definition of \verb|Mu|.  Ideally, we would like
to have a definition like
\begin{verbatim}
  Inductive Mu' : Set := mu' : F Mu' -> Mu'.
\end{verbatim}
\noindent This is exactly what is used in approaches to modular
datatypes in functional programming, like
Swierstra's~\cite{swierstra08}.  But this definition is (rightly)
rejected by Coq, as instantiations of
\verb|F| that are not strictly positive would be unsound.

Instead, the definition of \verb|Mu| in Figure~\ref{fig:mu} weakens
this ideal definition to a strictly positive approximation:
\begin{verbatim}
  Inductive Mu : Set := 
    mu : forall (R : Set), (R -> Mu) -> F R -> Mu.
\end{verbatim}
\noindent Instead of taking in \verb|F Mu|, constructor \verb|mu|
accepts an input of type \verb|F R|, for some type \verb|R| for which
we have a function of type \verb|R -> Mu|.  The impredicative
quantification of \verb|R| is essential here: we instantiate it with
\verb|Mu| itself in the definition of \verb|inMu|
(Figure~\ref{fig:mu}).  So this approach would not work in a
predicative theory like Agda's.  The quantification of \verb|R| can be
seen as applying a technique due to Mendler, of introducing
universally quantified variables for problematic type occurrences, to
a datatype constructor.  We will review this in
Section~\ref{sec:related}.

Returning to Figure~\ref{fig:mu}, we have functions \verb|inMu| and
\verb|outMu|, which make \verb|F Mu| a retraction (\verb|outIn|) of
\verb|Mu|: the composition of \verb|outMu| and \verb|inMu| is
(extensionally) the identity on \verb|F Mu|.  But the reverse
composition cannot be proved to be the identity, because of the basic
problem of \textbf{noncanonicity} that arises with this definition.

For a simple example: suppose we instantiate \verb|F| with
\verb|ListF| (of Figure~\ref{fig:listf}).  Our derivation uses a
different type that wraps \verb|F|, but this will show the issue in a
simple form.  Let us temporarily define \verb|List A| as
\verb|Mu (ListF A)| (again, for subsidiary recursion do not use just
\verb|ListF| directly).  The canonical way to define the empty list
would be, implicitly instantiating \verb|F| to \verb|ListF A|,
\begin{verbatim}
Definition mkNil := mu (List A) (fun x => x) (NilF A)
\end{verbatim}
\noindent But given this, there are infinitely many other equivalent
definitions.  For any \verb|Q : Set|, we could take
\begin{verbatim}
Definition mkNil' := mu Q (fun x => mkNil) (NilF A)
\end{verbatim}
\noindent Since \verb|fmap f (NilF A)| equals just \verb|NilF B| for
\verb|f : A -> B|, if we apply \verb|outMu| (of Figure~\ref{fig:mu})
to \verb|mkNil'| or \verb|mkNil|, we will get \verb|NilF (List A)|.
But critically, \verb|mkNil| and \verb|mkNil'| are not equal, neither
definitionally nor provably.  One can define a function that puts
\verb|Mu| values in normal form by folding \verb|inMu| over them.
Then \verb|mkNil| and \verb|mkNil'| will have the same normal form,
and be equivalent in that sense.  But the fact that they are not
provably equal is what we term noncanonicity.  

Noncanonicity must be handled carefully when reasoning about functions
defined with our interface.  We will see an example in
Section~\ref{sec:examplesi}.  First, though, let us complete the
exposition of our implementation of subsidiary recursion.

\subsection{The implementation of \texttt{Subrec} (\texttt{Subrec.v})}
\label{sec:subrecimpl}

The type \verb|Subrec| is defined in Figure~\ref{fig:subrec}, as a
fixed-point of \verb|SubrecF : Set -> Set|.  We take this fixed-point
with \verb|Mu|, discussed in the previous section, and obtain \verb|roll|
and \verb|unroll| functions between \verb|SubrecF Subrec| and \verb|Subrec|.
Unrolling \verb|Subrec| gives us the type
\begin{verbatim}
forall (X : Set -> Set) (FunX : Functor X), Alg Subrec X -> X Subrec
\end{verbatim}
\noindent So we see that \verb|Subrec| is the type of functions which,
for all algebras with anchor type \verb|Subrec| and functorial carrier
\verb|X|, compute a value of type \verb|X Subrec|.  This is a
generalization of the functor-generic type
$\forall\ X.\ \textit{Alg}\ X \to X$ for the Church encoding, where
$\textit{Alg}\ X$ is $F\ X \to X$.  We elide the implementation of the
\verb|roll| and \verb|unroll| functions, but note that \verb|unroll|
makes use of functoriality of carriers \verb|X|.

\begin{figure}
\begin{verbatim}
Definition SubrecF(C : Set) := 
  forall (X : Set -> Set) (FunX : Functor X), Alg C X -> X C.
Definition Subrec := Mu SubrecF.
Definition roll: SubrecF Subrec -> Subrec.
Definition unroll: Subrec -> SubrecF Subrec.
\end{verbatim}
\caption{Definition of \texttt{Subrec} as a fixed-point of \texttt{SubrecF}}
\label{fig:subrec}
\end{figure}

The rest of the interface for \verb|Subrec| is shown in
Figure~\ref{fig:subrecb}.  We have \verb|fold|, which is a fold
function with anchor type \verb|Subrec|.  To fold an algebra
\verb|alg| with carrier \verb|X| (with \verb|fmap| function given by
\verb|FunX|) over \verb|d : Subrec|, we \verb|unroll| the
definition of \verb|Subrec| and apply that to the algebra (with its
carrier).

More interesting is the definition of \verb|inn|, which is the
critical point where the recursion universe is implemented.  To create
a value of type \verb|Subrec| from data of type \verb|F Subrec|, the
definition of \verb|inn| \verb|roll|s a value of type
\verb|SubrecF Subrec| (we saw this type unfolded at the start of
this section).  This value takes in a carrier
\verb|X|, its fmap function \verb|xmap|, and an algebra \verb|alg|
with that carrier.  Note that the anchor type of this algebra is
\verb|Subrec|.  It will then call \verb|alg| (after \verb|unroll|ing
it) with implementations for the components of the recursion universe
(cf. Section~\ref{sec:recu}, also Figure~\ref{fig:algf}):
\begin{itemize}
\item \verb|Subrec| is passed as the value for the abstract type \verb|R|; this is what enables all
  the rest of the components to have the desired types, since we will pass values that have \verb|Subrec|
  where the interface mentions \verb|R|.
\item the identity function is passed as the value for \verb|reveal : R -> Subrec|.
\item The function \verb|fold|, which expects an algebra with anchor type \verb|Subrec|, is passed as
  the fold function of type \verb|FoldT Alg R|. 
\item For the \verb|eval : R -> X R| function, we pass \verb|(fold X xmap alg) : Subrec -> X Subrec|.
\item For the subdata structure of type \verb|F R|, we pass \verb|d : F Subrec|. 
\end{itemize}

Finally, Figure~\ref{fig:subrecb} defines \verb|out| as a subsidiary
recursion, given any fold function with its anchor type \verb|R|.  The
code for \verb|out| just folds an algebra over the input of type
\verb|R|, where that algebra simply returns the subdata structure it
is given.  Outside the recusion, this has type \verb|F R|; inside the
recursion it has type \verb|F R'| where \verb|R'| is the abstract type
of the subsidiary recursion (named in the figure just for discussion
here).  So \verb|out| implements the idea that unfolding an abstract
type one step is just a trivial case of subsidiary recursion.

\begin{figure}
\begin{verbatim}
Definition fold : FoldT Alg Subrec := 
  fun X FunX alg d => unroll d X FunX alg.

Definition inn : F Subrec -> Subrec :=
  fun d => roll (fun X xmap alg =>
                 unrollAlg alg Subrec (fun x => x) fold (fold X xmap alg) d).

Definition out{R:Set}(fo:FoldT Alg R) : R -> F R :=
  fo F FunF (rollAlg (fun R' _ _ _ d => d)).
\end{verbatim}
\caption{The rest of the interface for \texttt{Subrec}}
\label{fig:subrecb}
\end{figure}


\section{Interface for subsidiary induction (\texttt{Subreci.v})}
\label{sec:interfacei}

We have seen how to write subsidiary recursions in Coq.  But can one
reason about these?  To wrap up this paper, we will see an interface
for subsidiary induction in Coq, and example proofs written using this
interface.  Subsidiary induction is written just as the natural
extension of subsidiary recursion, which worked over \verb|Set|s, to
\verb|Subrec|-predicates.  The development is parametrized by a
functor \verb|F| and a functor
\verb|Fi : (Subrec -> Prop) -> (Subrec -> Prop)| over
\verb|Subrec|-indexed propositions (i.e., predicates).  Just as
functors need an \verb|fmap| function, we here need an indexed
version, of type \verb|fmapiT Subrec Fi| (definition elided.)

The central definitions for the type \verb|Subreci : Subrec -> Prop|
are given in Figure~\ref{fig:subreci}.  Where having a value \verb|x|
of \verb|Subrec| entitles us to define subsidiary recursions to
inhabit types \verb|X Subrec|, a value of type \verb|Subreci x| lets
us prove properties of \verb|x| by subsidiary induction.  Briefly:
\verb|kMo| is the kind for \emph{motives}, namely predicates on
\verb|Subrec|~\cite{mcbride00}.  \verb|KAlgi| is the kind for indexed
algebras.  \verb|FoldTi| is the indexed version of \verb|FoldT|: it is
expresses provability of \verb|X C| for \verb|d|, based on an indexed
algebra and a value of type \verb|C d|, where \verb|C| is the anchor
type, now indexed.  \verb|AlgFi| and \verb|Algi| are indexed versions
of the algebras we saw for recursion.  The \verb|eval| function
(Figure~\ref{fig:algf}) has now become an induction hypothesis: given
any \verb|d| where \verb|R d| holds, \verb|ih| proves \verb|X R d|.  A
value of type \verb|R d| is thus a license to induct on \verb|d|.
Finally, the algebra is given a subdata structure indexed by
\verb|d : Subrec|, and must produce a proof of \verb|X R d|.  \verb|Subreci|
is defined as the suitably indexed fixed-point of \verb|SubrecFi|, which
is the natural indexed version of \verb|SubrecF|.


\begin{figure}
\begin{verbatim}
Definition kMo := Subrec -> Prop.
Definition KAlgi := kMo -> (kMo -> kMo) -> Set.
Definition FoldTi(alg : KAlgi)(C : kMo) : kMo :=
  fun d => forall (X : kMo -> kMo) (xmap : fmapiT Subrec X), 
           alg C X -> C d -> X C d.

Definition AlgFi(A: KAlgi)(C : kMo)(X : kMo -> kMo) : Set :=
  forall (R : kMo)
    (reveal : (forall (d : Subrec), R d -> C d))        
    (fo : (forall (d : Subrec), FoldTi A R d))
    (ih : (forall (d : Subrec), R d -> X R d))
    (d : Subrec),
    Fi R d -> X R d.

Definition Algi := MuAlgi Subrec AlgFi.

Definition SubrecFi(C : kMo) : kMo := 
  fun d => forall (X : kMo -> kMo) (xmap : fmapiT Subrec X), Algi C X -> X C d.
Definition Subreci := Mui Subrec SubrecFi.

Definition foldi(i : Subrec) : FoldTi Algi Subreci i.
Definition inni(i : Subrec)(fd : Fi Subreci i) : Subreci i.
\end{verbatim}
\caption{Interface for subsidiary induction}
\label{fig:subreci}
\end{figure}

For lists, we instantiate \verb|Fi| with \verb|ListFi|, shown in
Figure~\ref{fig:listfi}.  This is just the indexed version of
\verb|ListF|.  Given a \verb|list A|, \verb|toListi| returns
a value of type \verb|Listi (toList xs)|.  This can be understood
as saying that for any list (from Coq's standard library),
we can reason by subsidiary induction to prove properties of \verb|toList xs|.
We also introduce an abbreviation \verb|ListFoldTi| for the type
of indexed fold functions over lists.

\begin{figure}
\begin{verbatim}
Definition lkMo := List -> Prop.

Inductive ListFi(R : lkMo) : lkMo :=
  nilFi : ListFi R mkNil
| consFi : forall (h : A)(t : List), R t -> ListFi R (mkCons h t).

Definition Listi := Subreci ListF ListFi.
Definition toListi(xs : list A) : Listi (toList xs) := listFoldi xs Listi inni.
Definition ListFoldTi(R : List -> Prop)(d : List) : Prop :=
  FoldTi ListF (Algi ListF ListFi) R d.
\end{verbatim}
\caption{The indexed version \texttt{ListFi} of \texttt{ListF}}
\label{fig:listfi}
\end{figure}

\section{Examples of subsidiary induction}
\label{sec:examplesi}

For proving the main theorem about run-length encoding, we need
several lemmas about \verb|span|, shown in Figure~\ref{fig:spanlem}.
For lack of space, we just state the properties.  The first says that
appending the results of a call to span returns the original list
(module some conversions to \verb|list| from \verb|List|).  The second
uses the inductive type \verb|Forall| from Coq's standard library to
state that all the elements of the prefix returned by \verb|span|
satisfy \verb|p|.  These lemmas are proved using an indexed algebra
where the indexed anchor type is not used (so the carriers are
constant indexed-functor returning the types shown).  But
\verb|GuardPresF| uses the indexed anchor type (its argument \verb|S|),
to express that whenever \verb|spanh| returns a suffix \verb|r|, that
suffix satisfies the indexed anchor type.  This enables us to invoke
an outer induction hypothesis on this suffix, when using \verb|span|
subsidiarily.  Using these lemmas, we can write a short proof by
subsidiary induction of the following, where
\verb|rld : list (nat * A) -> list A| is the obvious decoding
function:

\begin{verbatim}
Theorem RldRle (xs : list A): rld (rle (toList xs)) = xs.  
\end{verbatim}

\noindent We invoke the lemmas about \verb|span| subsidiarily,
so that we may apply our induction hypothesis to the suffix
that \verb|span| returns (on which \verb|mapThrough| then recurses).
For example, the lemma for \verb|GuardPresF| takes in the
indexed fold function \verb|foi| from the outer induction (for \verb|RldRle|),
to show that the abstract predicate \verb|R| applies to the suffix
\verb|r| returned by \verb|span|.  This enables the outer induction
hypothesis (for \verb|RldRle|) to be applied.

\begin{verbatim}
Lemma guardPres{R : List A -> Prop}(foi:forall d : List A, ListFoldTi R d)
      (p : A -> bool)(xs : List A)(rxs : R xs)
      (l:list A)(r : List A)(e: span p xs = (l,r)) : R r.
\end{verbatim} 

\begin{figure}
\begin{verbatim}
Definition SpanAppendF(p : A -> bool)(xs : List A) : Prop :=
  forall (l : list A)(r : List A) ,
    span p xs = (l,r) ->
    fromList xs = l ++ (fromList r).

Definition spanForallF(p : A -> bool)(xs : List A) : Prop :=
  forall (l : list A)(r : List A),
    span p xs = (l,r) ->
    Forall (fun a => p a = true) l.

Definition GuardPresF(p : A -> bool)(S : List A -> Prop)(xs : List A) : Prop :=
  forall (l : list A)(r : List A),
    spanh p xs = SpanSomeMatch l r ->
    S r.
\end{verbatim}
\caption{Statements of three lemmas about \texttt{span}}
\label{fig:spanlem}
\end{figure}

Finally, as promised, a note on noncanonicity. When proving properties about subsidiary
recursions on \verb|xs : List A|, one should be aware that nothing prevents
the property from being applied to noncanonical \verb|List|s.  For example,
suppose we wish to prove that if all elements of a  list satisfy \verb|p|, then
the suffix returned by \verb|span| is empty.  It is dangerous to phrase
this as ``the suffix equals \verb|mkNil|'', because for a noncanonical input \verb|xs|,
\verb|span| will return that same  noncanonical \verb|xs| as the suffix (and so
it may be a noncanonical empty list, not equal to \verb|mkNil|).  The solution
in this case is to use a function \verb|getNil| (\verb|List.v|) that computes
an empty list from \verb|xs|.  So the statement that one can prove is:

\begin{verbatim}
Definition spanForall2F(p : A -> bool)(xs : List A) : Prop :=
  Forall (fun a => p a = true) (fromList xs) ->
  span p xs = (fromList xs, getNil xs).
\end{verbatim}

\section{Related Work}
\label{sec:related}

\textbf{Termination.}
In some tools, like Coq, Agda, and Lean, termination is checked
statically, based on structural decrease at recursive calls.  Others,
like Isabelle/HOL, allow one to write recursions first, and prove
(possibly with automated help) their termination
afterwards~\cite{krauss}.

It has not escaped the notice of designers of ITPs that structural
recursion is not the only form of terminating recursion.  All the
mentioned tools provide support for well-founded recursion, where for
recursive calls, one must show that the parameter of recursion has
decreased in some well-founded order.

Subsidiary recursion can be seen as a generalization of \emph{nested
recursion}, which allows recursive calls of the form \verb|f (f x)|.
In subsidiary recursion, these are generalized to the form
\verb|f (g x)|, where \verb|g| could be \verb|f| or another
recursively defined function.

\textbf{Mendler encoding.}
Mendler introduced the basic idea of using universal abstraction to
support compositional termination checking; an accessible source
is~\cite{mendler91}.  He introduces a functor-generic recursor of type
\[
\all{X}{(\all{R}{(R \to X) \to F\ R \to X}) \to \mu\ F\ \to X}
\]
\noindent We have adopted this idea to the constructor of the type
\verb|Mu| (Section~\ref{sec:mu}).  Previous work explored the
categorical perspective on Mendler-style recursion~\cite{uustalu99}.
Others have explored the possibility of using it with negative type
schemes~\cite{ahn11}.

\section{Conclusion}

\bibliography{biblio}

\end{document}
